; generated by ARM C/C++ Compiler, 5.03 [Build 76]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\appcallback.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\appcallback.d --cpu=Cortex-M0 --apcs=interwork -O0 -I.\BSP_lib\Inc\Driver -I.\CMSIS\CMOSupport -I.\CMSIS\NUC1xxSupport -I.\User\inc -I.\modbus\include -I.\modbus\MBport -I.\modbus\rtu -I"D:\Program Files\keil\ARM\RV31\INC" -I"D:\Program Files\keil\ARM\CMSIS\Include" -I"D:\Program Files\keil\ARM\Inc\Nuvoton\NUC1xx" --omf_browse=.\obj\appcallback.crf modbus\APPCALLBACK\AppCallBack.c]
                          THUMB

                          AREA ||i.eMBRegCoilsCB||, CODE, READONLY, ALIGN=1

                  eMBRegCoilsCB PROC
;;;48     eMBErrorCode
;;;49     eMBRegCoilsCB( UCHAR * pucRegBuffer, USHORT usAddress, USHORT usNCoils, eMBRegisterMode eMode )
000000  b510              PUSH     {r4,lr}
;;;50     {
000002  4604              MOV      r4,r0
;;;51         ( void )pucRegBuffer;
;;;52         ( void )usAddress;
;;;53         ( void )usNCoils;
;;;54         ( void )eMode;
;;;55         return MB_ENOREG;
000004  2001              MOVS     r0,#1
;;;56     }
000006  bd10              POP      {r4,pc}
;;;57     
                          ENDP


                          AREA ||i.eMBRegDiscreteCB||, CODE, READONLY, ALIGN=1

                  eMBRegDiscreteCB PROC
;;;58     eMBErrorCode
;;;59     eMBRegDiscreteCB( UCHAR * pucRegBuffer, USHORT usAddress, USHORT usNDiscrete )
000000  4603              MOV      r3,r0
;;;60     {
;;;61         ( void )pucRegBuffer;
;;;62         ( void )usAddress;
;;;63         ( void )usNDiscrete;
;;;64         return MB_ENOREG;
000002  2001              MOVS     r0,#1
;;;65     }
000004  4770              BX       lr
;;;66     
                          ENDP


                          AREA ||i.eMBRegHoldingCB||, CODE, READONLY, ALIGN=1

                  eMBRegHoldingCB PROC
;;;37     eMBErrorCode
;;;38     eMBRegHoldingCB( UCHAR * pucRegBuffer, USHORT usAddress, USHORT usNRegs, eMBRegisterMode eMode )
000000  b510              PUSH     {r4,lr}
;;;39     {
000002  4604              MOV      r4,r0
;;;40         ( void )pucRegBuffer;
;;;41         ( void )usAddress;
;;;42         ( void )usNRegs;
;;;43         ( void )eMode;
;;;44         return MB_ENOREG;
000004  2001              MOVS     r0,#1
;;;45     }
000006  bd10              POP      {r4,pc}
;;;46     
                          ENDP


                          AREA ||i.eMBRegInputCB||, CODE, READONLY, ALIGN=2

                  eMBRegInputCB PROC
;;;11     eMBErrorCode
;;;12     eMBRegInputCB( UCHAR * pucRegBuffer, USHORT usAddress, USHORT usNRegs )
000000  b570              PUSH     {r4-r6,lr}
;;;13     {
000002  4603              MOV      r3,r0
;;;14         eMBErrorCode    eStatus = MB_ENOERR;
000004  2000              MOVS     r0,#0
;;;15         int             iRegIndex;
;;;16     
;;;17         if( ( usAddress >= REG_INPUT_START )
000006  257d              MOVS     r5,#0x7d
000008  00ed              LSLS     r5,r5,#3
00000a  42a9              CMP      r1,r5
00000c  db18              BLT      |L4.64|
;;;18             && ( usAddress + usNRegs <= REG_INPUT_START + REG_INPUT_NREGS ) )
00000e  188d              ADDS     r5,r1,r2
000010  26fb              MOVS     r6,#0xfb
000012  00b6              LSLS     r6,r6,#2
000014  42b5              CMP      r5,r6
000016  dc13              BGT      |L4.64|
;;;19         {
;;;20             iRegIndex = ( int )( usAddress - usRegInputStart );
000018  4d0a              LDR      r5,|L4.68|
00001a  882d              LDRH     r5,[r5,#0]  ; usRegInputStart
00001c  1b4c              SUBS     r4,r1,r5
;;;21             while( usNRegs > 0 )
00001e  e00c              B        |L4.58|
                  |L4.32|
;;;22             {
;;;23                 *pucRegBuffer++ = ( unsigned char )( usRegInputBuf[iRegIndex] >> 8 );
000020  0065              LSLS     r5,r4,#1
000022  4e09              LDR      r6,|L4.72|
000024  5b75              LDRH     r5,[r6,r5]
000026  122d              ASRS     r5,r5,#8
000028  701d              STRB     r5,[r3,#0]
00002a  1c5b              ADDS     r3,r3,#1
;;;24                 *pucRegBuffer++ = ( unsigned char )( usRegInputBuf[iRegIndex] & 0xFF );
00002c  0065              LSLS     r5,r4,#1
00002e  5d75              LDRB     r5,[r6,r5]
000030  701d              STRB     r5,[r3,#0]
000032  1c5b              ADDS     r3,r3,#1
;;;25                 iRegIndex++;
000034  1c64              ADDS     r4,r4,#1
;;;26                 usNRegs--;
000036  1e55              SUBS     r5,r2,#1
000038  b2aa              UXTH     r2,r5
                  |L4.58|
00003a  2a00              CMP      r2,#0                 ;21
00003c  dcf0              BGT      |L4.32|
00003e  e000              B        |L4.66|
                  |L4.64|
;;;27             }
;;;28         }
;;;29         else
;;;30         {
;;;31             eStatus = MB_ENOREG;
000040  2001              MOVS     r0,#1
                  |L4.66|
;;;32         }
;;;33     
;;;34         return eStatus;
;;;35     }
000042  bd70              POP      {r4-r6,pc}
;;;36     
                          ENDP

                  |L4.68|
                          DCD      usRegInputStart
                  |L4.72|
                          DCD      usRegInputBuf

                          AREA ||.data||, DATA, ALIGN=1

                  usRegInputStart
000000  03e8              DCW      0x03e8
                  usRegInputBuf
000002  0000              DCB      0x00,0x00
                          DCDU     0x00000000
000008  0000              DCB      0x00,0x00
