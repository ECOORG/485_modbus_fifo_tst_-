; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\mbfunccoils.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\mbfunccoils.d --cpu=Cortex-M0 --apcs=interwork -O0 -I.\BSP_lib\Inc\Driver -I.\CMSIS\CMOSupport -I.\CMSIS\NUC1xxSupport -I.\User\inc -I.\modbus\include -I.\modbus\MBport -I.\modbus\rtu -I"D:\Program Files\keil\ARM\RV31\INC" -I"D:\Program Files\keil\ARM\PACK\ARM\CMSIS\3.20.4\CMSIS\Include" -I"D:\Program Files\keil\ARM\Inc\Nuvoton\NUC1xx" --omf_browse=.\obj\mbfunccoils.crf modbus\functions\mbfunccoils.c]
                          THUMB

                          AREA ||i.eMBFuncReadCoils||, CODE, READONLY, ALIGN=1

                  eMBFuncReadCoils PROC
;;;68     eMBException
;;;69     eMBFuncReadCoils( UCHAR * pucFrame, USHORT * usLen )
000000  b5f0              PUSH     {r4-r7,lr}
;;;70     {
000002  b085              SUB      sp,sp,#0x14
000004  4606              MOV      r6,r0
000006  460d              MOV      r5,r1
;;;71         USHORT          usRegAddress;
;;;72         USHORT          usCoilCount;
;;;73         UCHAR           ucNBytes;
;;;74         UCHAR          *pucFrameCur;
;;;75     
;;;76         eMBException    eStatus = MB_EX_NONE;
000008  2000              MOVS     r0,#0
00000a  9001              STR      r0,[sp,#4]
;;;77         eMBErrorCode    eRegStatus;
;;;78     
;;;79         if( *usLen == ( MB_PDU_FUNC_READ_SIZE + MB_PDU_SIZE_MIN ) )
00000c  8828              LDRH     r0,[r5,#0]
00000e  2805              CMP      r0,#5
000010  d14e              BNE      |L1.176|
;;;80         {
;;;81             usRegAddress = ( USHORT )( pucFrame[MB_PDU_FUNC_READ_ADDR_OFF] << 8 );
000012  7870              LDRB     r0,[r6,#1]
000014  0200              LSLS     r0,r0,#8
000016  9003              STR      r0,[sp,#0xc]
;;;82             usRegAddress |= ( USHORT )( pucFrame[MB_PDU_FUNC_READ_ADDR_OFF + 1] );
000018  78b0              LDRB     r0,[r6,#2]
00001a  9903              LDR      r1,[sp,#0xc]
00001c  4308              ORRS     r0,r0,r1
00001e  9003              STR      r0,[sp,#0xc]
;;;83             usRegAddress++;
000020  9803              LDR      r0,[sp,#0xc]
000022  1c40              ADDS     r0,r0,#1
000024  b280              UXTH     r0,r0
000026  9003              STR      r0,[sp,#0xc]
;;;84     
;;;85             usCoilCount = ( USHORT )( pucFrame[MB_PDU_FUNC_READ_COILCNT_OFF] << 8 );
000028  78f0              LDRB     r0,[r6,#3]
00002a  0204              LSLS     r4,r0,#8
;;;86             usCoilCount |= ( USHORT )( pucFrame[MB_PDU_FUNC_READ_COILCNT_OFF + 1] );
00002c  7930              LDRB     r0,[r6,#4]
00002e  4304              ORRS     r4,r4,r0
;;;87     
;;;88             /* Check if the number of registers to read is valid. If not
;;;89              * return Modbus illegal data value exception. 
;;;90              */
;;;91             if( ( usCoilCount >= 1 ) &&
000030  2c01              CMP      r4,#1
000032  db3a              BLT      |L1.170|
;;;92                 ( usCoilCount < MB_PDU_FUNC_READ_COILCNT_MAX ) )
000034  207d              MOVS     r0,#0x7d
000036  0100              LSLS     r0,r0,#4
000038  4284              CMP      r4,r0
00003a  da36              BGE      |L1.170|
;;;93             {
;;;94                 /* Set the current PDU data pointer to the beginning. */
;;;95                 pucFrameCur = &pucFrame[MB_PDU_FUNC_OFF];
00003c  4637              MOV      r7,r6
;;;96                 *usLen = MB_PDU_FUNC_OFF;
00003e  2000              MOVS     r0,#0
000040  8028              STRH     r0,[r5,#0]
;;;97     
;;;98                 /* First byte contains the function code. */
;;;99                 *pucFrameCur++ = MB_FUNC_READ_COILS;
000042  2001              MOVS     r0,#1
000044  7038              STRB     r0,[r7,#0]
000046  1c7f              ADDS     r7,r7,#1
;;;100                *usLen += 1;
000048  8828              LDRH     r0,[r5,#0]
00004a  1c40              ADDS     r0,r0,#1
00004c  8028              STRH     r0,[r5,#0]
;;;101    
;;;102                /* Test if the quantity of coils is a multiple of 8. If not last
;;;103                 * byte is only partially field with unused coils set to zero. */
;;;104                if( ( usCoilCount & 0x0007 ) != 0 )
00004e  0760              LSLS     r0,r4,#29
000050  0f40              LSRS     r0,r0,#29
000052  2800              CMP      r0,#0
000054  d008              BEQ      |L1.104|
;;;105                {
;;;106                    ucNBytes = ( UCHAR )( usCoilCount / 8 + 1 );
000056  4620              MOV      r0,r4
000058  17e1              ASRS     r1,r4,#31
00005a  0f49              LSRS     r1,r1,#29
00005c  1809              ADDS     r1,r1,r0
00005e  10c9              ASRS     r1,r1,#3
000060  1c49              ADDS     r1,r1,#1
000062  b2c9              UXTB     r1,r1
000064  9102              STR      r1,[sp,#8]
000066  e006              B        |L1.118|
                  |L1.104|
;;;107                }
;;;108                else
;;;109                {
;;;110                    ucNBytes = ( UCHAR )( usCoilCount / 8 );
000068  4620              MOV      r0,r4
00006a  17e1              ASRS     r1,r4,#31
00006c  0f49              LSRS     r1,r1,#29
00006e  1809              ADDS     r1,r1,r0
000070  0549              LSLS     r1,r1,#21
000072  0e09              LSRS     r1,r1,#24
000074  9102              STR      r1,[sp,#8]
                  |L1.118|
;;;111                }
;;;112                *pucFrameCur++ = ucNBytes;
000076  9802              LDR      r0,[sp,#8]
000078  7038              STRB     r0,[r7,#0]
00007a  1c7f              ADDS     r7,r7,#1
;;;113                *usLen += 1;
00007c  8828              LDRH     r0,[r5,#0]
00007e  1c40              ADDS     r0,r0,#1
000080  8028              STRH     r0,[r5,#0]
;;;114    
;;;115                eRegStatus =
000082  2300              MOVS     r3,#0
000084  4622              MOV      r2,r4
000086  4638              MOV      r0,r7
000088  9903              LDR      r1,[sp,#0xc]
00008a  f7fffffe          BL       eMBRegCoilsCB
00008e  9000              STR      r0,[sp,#0]
;;;116                    eMBRegCoilsCB( pucFrameCur, usRegAddress, usCoilCount,
;;;117                                   MB_REG_READ );
;;;118    
;;;119                /* If an error occured convert it into a Modbus exception. */
;;;120                if( eRegStatus != MB_ENOERR )
000090  9800              LDR      r0,[sp,#0]
000092  2800              CMP      r0,#0
000094  d004              BEQ      |L1.160|
;;;121                {
;;;122                    eStatus = prveMBError2Exception( eRegStatus );
000096  9800              LDR      r0,[sp,#0]
000098  f7fffffe          BL       prveMBError2Exception
00009c  9001              STR      r0,[sp,#4]
00009e  e009              B        |L1.180|
                  |L1.160|
;;;123                }
;;;124                else
;;;125                {
;;;126                    /* The response contains the function code, the starting address
;;;127                     * and the quantity of registers. We reuse the old values in the 
;;;128                     * buffer because they are still valid. */
;;;129                    *usLen += ucNBytes;;
0000a0  8829              LDRH     r1,[r5,#0]
0000a2  9802              LDR      r0,[sp,#8]
0000a4  1808              ADDS     r0,r1,r0
0000a6  8028              STRH     r0,[r5,#0]
0000a8  e004              B        |L1.180|
                  |L1.170|
;;;130                }
;;;131            }
;;;132            else
;;;133            {
;;;134                eStatus = MB_EX_ILLEGAL_DATA_VALUE;
0000aa  2003              MOVS     r0,#3
0000ac  9001              STR      r0,[sp,#4]
0000ae  e001              B        |L1.180|
                  |L1.176|
;;;135            }
;;;136        }
;;;137        else
;;;138        {
;;;139            /* Can't be a valid read coil register request because the length
;;;140             * is incorrect. */
;;;141            eStatus = MB_EX_ILLEGAL_DATA_VALUE;
0000b0  2003              MOVS     r0,#3
0000b2  9001              STR      r0,[sp,#4]
                  |L1.180|
;;;142        }
;;;143        return eStatus;
0000b4  9801              LDR      r0,[sp,#4]
;;;144    }
0000b6  b005              ADD      sp,sp,#0x14
0000b8  bdf0              POP      {r4-r7,pc}
;;;145    
                          ENDP


                          AREA ||i.eMBFuncWriteCoil||, CODE, READONLY, ALIGN=1

                  eMBFuncWriteCoil PROC
;;;147    eMBException
;;;148    eMBFuncWriteCoil( UCHAR * pucFrame, USHORT * usLen )
000000  b5fe              PUSH     {r1-r7,lr}
;;;149    {
000002  4604              MOV      r4,r0
000004  460f              MOV      r7,r1
;;;150        USHORT          usRegAddress;
;;;151        UCHAR           ucBuf[2];
;;;152    
;;;153        eMBException    eStatus = MB_EX_NONE;
000006  2000              MOVS     r0,#0
000008  9000              STR      r0,[sp,#0]
;;;154        eMBErrorCode    eRegStatus;
;;;155    
;;;156        if( *usLen == ( MB_PDU_FUNC_WRITE_SIZE + MB_PDU_SIZE_MIN ) )
00000a  8838              LDRH     r0,[r7,#0]
00000c  2805              CMP      r0,#5
00000e  d12b              BNE      |L2.104|
;;;157        {
;;;158            usRegAddress = ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_ADDR_OFF] << 8 );
000010  7860              LDRB     r0,[r4,#1]
000012  0205              LSLS     r5,r0,#8
;;;159            usRegAddress |= ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_ADDR_OFF + 1] );
000014  78a0              LDRB     r0,[r4,#2]
000016  4305              ORRS     r5,r5,r0
;;;160            usRegAddress++;
000018  1c68              ADDS     r0,r5,#1
00001a  b285              UXTH     r5,r0
;;;161    
;;;162            if( ( pucFrame[MB_PDU_FUNC_WRITE_VALUE_OFF + 1] == 0x00 ) &&
00001c  7920              LDRB     r0,[r4,#4]
00001e  2800              CMP      r0,#0
000020  d11f              BNE      |L2.98|
;;;163                ( ( pucFrame[MB_PDU_FUNC_WRITE_VALUE_OFF] == 0xFF ) ||
000022  78e0              LDRB     r0,[r4,#3]
000024  28ff              CMP      r0,#0xff
000026  d002              BEQ      |L2.46|
;;;164                  ( pucFrame[MB_PDU_FUNC_WRITE_VALUE_OFF] == 0x00 ) ) )
000028  78e0              LDRB     r0,[r4,#3]
00002a  2800              CMP      r0,#0
00002c  d119              BNE      |L2.98|
                  |L2.46|
;;;165            {
;;;166                ucBuf[1] = 0;
00002e  2000              MOVS     r0,#0
000030  4669              MOV      r1,sp
000032  7148              STRB     r0,[r1,#5]
;;;167                if( pucFrame[MB_PDU_FUNC_WRITE_VALUE_OFF] == 0xFF )
000034  78e0              LDRB     r0,[r4,#3]
000036  28ff              CMP      r0,#0xff
000038  d102              BNE      |L2.64|
;;;168                {
;;;169                    ucBuf[0] = 1;
00003a  2001              MOVS     r0,#1
00003c  7108              STRB     r0,[r1,#4]
00003e  e002              B        |L2.70|
                  |L2.64|
;;;170                }
;;;171                else
;;;172                {
;;;173                    ucBuf[0] = 0;
000040  2000              MOVS     r0,#0
000042  4669              MOV      r1,sp
000044  7108              STRB     r0,[r1,#4]
                  |L2.70|
;;;174                }
;;;175                eRegStatus =
000046  2301              MOVS     r3,#1
000048  461a              MOV      r2,r3
00004a  4629              MOV      r1,r5
00004c  a801              ADD      r0,sp,#4
00004e  f7fffffe          BL       eMBRegCoilsCB
000052  4606              MOV      r6,r0
;;;176                    eMBRegCoilsCB( &ucBuf[0], usRegAddress, 1, MB_REG_WRITE );
;;;177    
;;;178                /* If an error occured convert it into a Modbus exception. */
;;;179                if( eRegStatus != MB_ENOERR )
000054  2e00              CMP      r6,#0
000056  d009              BEQ      |L2.108|
;;;180                {
;;;181                    eStatus = prveMBError2Exception( eRegStatus );
000058  4630              MOV      r0,r6
00005a  f7fffffe          BL       prveMBError2Exception
00005e  9000              STR      r0,[sp,#0]
000060  e004              B        |L2.108|
                  |L2.98|
;;;182                }
;;;183            }
;;;184            else
;;;185            {
;;;186                eStatus = MB_EX_ILLEGAL_DATA_VALUE;
000062  2003              MOVS     r0,#3
000064  9000              STR      r0,[sp,#0]
000066  e001              B        |L2.108|
                  |L2.104|
;;;187            }
;;;188        }
;;;189        else
;;;190        {
;;;191            /* Can't be a valid write coil register request because the length
;;;192             * is incorrect. */
;;;193            eStatus = MB_EX_ILLEGAL_DATA_VALUE;
000068  2003              MOVS     r0,#3
00006a  9000              STR      r0,[sp,#0]
                  |L2.108|
;;;194        }
;;;195        return eStatus;
00006c  9800              LDR      r0,[sp,#0]
;;;196    }
00006e  bdfe              POP      {r1-r7,pc}
;;;197    
                          ENDP


                          AREA ||i.eMBFuncWriteMultipleCoils||, CODE, READONLY, ALIGN=1

                  eMBFuncWriteMultipleCoils PROC
;;;201    eMBException
;;;202    eMBFuncWriteMultipleCoils( UCHAR * pucFrame, USHORT * usLen )
000000  b5f0              PUSH     {r4-r7,lr}
;;;203    {
000002  b085              SUB      sp,sp,#0x14
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
;;;204        USHORT          usRegAddress;
;;;205        USHORT          usCoilCnt;
;;;206        UCHAR           ucByteCount;
;;;207        UCHAR           ucByteCountVerify;
;;;208    
;;;209        eMBException    eStatus = MB_EX_NONE;
000008  2000              MOVS     r0,#0
00000a  9001              STR      r0,[sp,#4]
;;;210        eMBErrorCode    eRegStatus;
;;;211    
;;;212        if( *usLen > ( MB_PDU_FUNC_WRITE_SIZE + MB_PDU_SIZE_MIN ) )
00000c  8830              LDRH     r0,[r6,#0]
00000e  2805              CMP      r0,#5
000010  dd3e              BLE      |L3.144|
;;;213        {
;;;214            usRegAddress = ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_MUL_ADDR_OFF] << 8 );
000012  7868              LDRB     r0,[r5,#1]
000014  0207              LSLS     r7,r0,#8
;;;215            usRegAddress |= ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_MUL_ADDR_OFF + 1] );
000016  78a8              LDRB     r0,[r5,#2]
000018  4307              ORRS     r7,r7,r0
;;;216            usRegAddress++;
00001a  1c78              ADDS     r0,r7,#1
00001c  b287              UXTH     r7,r0
;;;217    
;;;218            usCoilCnt = ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_MUL_COILCNT_OFF] << 8 );
00001e  78e8              LDRB     r0,[r5,#3]
000020  0204              LSLS     r4,r0,#8
;;;219            usCoilCnt |= ( USHORT )( pucFrame[MB_PDU_FUNC_WRITE_MUL_COILCNT_OFF + 1] );
000022  7928              LDRB     r0,[r5,#4]
000024  4304              ORRS     r4,r4,r0
;;;220    
;;;221            ucByteCount = pucFrame[MB_PDU_FUNC_WRITE_MUL_BYTECNT_OFF];
000026  7968              LDRB     r0,[r5,#5]
000028  9003              STR      r0,[sp,#0xc]
;;;222    
;;;223            /* Compute the number of expected bytes in the request. */
;;;224            if( ( usCoilCnt & 0x0007 ) != 0 )
00002a  0760              LSLS     r0,r4,#29
00002c  0f40              LSRS     r0,r0,#29
00002e  2800              CMP      r0,#0
000030  d008              BEQ      |L3.68|
;;;225            {
;;;226                ucByteCountVerify = ( UCHAR )( usCoilCnt / 8 + 1 );
000032  4620              MOV      r0,r4
000034  17e1              ASRS     r1,r4,#31
000036  0f49              LSRS     r1,r1,#29
000038  1809              ADDS     r1,r1,r0
00003a  10c9              ASRS     r1,r1,#3
00003c  1c49              ADDS     r1,r1,#1
00003e  b2c9              UXTB     r1,r1
000040  9102              STR      r1,[sp,#8]
000042  e006              B        |L3.82|
                  |L3.68|
;;;227            }
;;;228            else
;;;229            {
;;;230                ucByteCountVerify = ( UCHAR )( usCoilCnt / 8 );
000044  4620              MOV      r0,r4
000046  17e1              ASRS     r1,r4,#31
000048  0f49              LSRS     r1,r1,#29
00004a  1809              ADDS     r1,r1,r0
00004c  0549              LSLS     r1,r1,#21
00004e  0e09              LSRS     r1,r1,#24
000050  9102              STR      r1,[sp,#8]
                  |L3.82|
;;;231            }
;;;232    
;;;233            if( ( usCoilCnt >= 1 ) &&
000052  2c01              CMP      r4,#1
000054  db19              BLT      |L3.138|
;;;234                ( usCoilCnt <= MB_PDU_FUNC_WRITE_MUL_COILCNT_MAX ) &&
000056  207b              MOVS     r0,#0x7b
000058  0100              LSLS     r0,r0,#4
00005a  4284              CMP      r4,r0
00005c  dc15              BGT      |L3.138|
;;;235                ( ucByteCountVerify == ucByteCount ) )
00005e  9903              LDR      r1,[sp,#0xc]
000060  9802              LDR      r0,[sp,#8]
000062  4288              CMP      r0,r1
000064  d111              BNE      |L3.138|
;;;236            {
;;;237                eRegStatus =
000066  2301              MOVS     r3,#1
000068  4622              MOV      r2,r4
00006a  4639              MOV      r1,r7
00006c  1da8              ADDS     r0,r5,#6
00006e  f7fffffe          BL       eMBRegCoilsCB
000072  9000              STR      r0,[sp,#0]
;;;238                    eMBRegCoilsCB( &pucFrame[MB_PDU_FUNC_WRITE_MUL_VALUES_OFF],
;;;239                                   usRegAddress, usCoilCnt, MB_REG_WRITE );
;;;240    
;;;241                /* If an error occured convert it into a Modbus exception. */
;;;242                if( eRegStatus != MB_ENOERR )
000074  9800              LDR      r0,[sp,#0]
000076  2800              CMP      r0,#0
000078  d004              BEQ      |L3.132|
;;;243                {
;;;244                    eStatus = prveMBError2Exception( eRegStatus );
00007a  9800              LDR      r0,[sp,#0]
00007c  f7fffffe          BL       prveMBError2Exception
000080  9001              STR      r0,[sp,#4]
000082  e007              B        |L3.148|
                  |L3.132|
;;;245                }
;;;246                else
;;;247                {
;;;248                    /* The response contains the function code, the starting address
;;;249                     * and the quantity of registers. We reuse the old values in the 
;;;250                     * buffer because they are still valid. */
;;;251                    *usLen = MB_PDU_FUNC_WRITE_MUL_BYTECNT_OFF;
000084  2005              MOVS     r0,#5
000086  8030              STRH     r0,[r6,#0]
000088  e004              B        |L3.148|
                  |L3.138|
;;;252                }
;;;253            }
;;;254            else
;;;255            {
;;;256                eStatus = MB_EX_ILLEGAL_DATA_VALUE;
00008a  2003              MOVS     r0,#3
00008c  9001              STR      r0,[sp,#4]
00008e  e001              B        |L3.148|
                  |L3.144|
;;;257            }
;;;258        }
;;;259        else
;;;260        {
;;;261            /* Can't be a valid write coil register request because the length
;;;262             * is incorrect. */
;;;263            eStatus = MB_EX_ILLEGAL_DATA_VALUE;
000090  2003              MOVS     r0,#3
000092  9001              STR      r0,[sp,#4]
                  |L3.148|
;;;264        }
;;;265        return eStatus;
000094  9801              LDR      r0,[sp,#4]
;;;266    }
000096  b005              ADD      sp,sp,#0x14
000098  bdf0              POP      {r4-r7,pc}
;;;267    
                          ENDP

