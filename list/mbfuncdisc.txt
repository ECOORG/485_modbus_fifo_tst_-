; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\mbfuncdisc.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\mbfuncdisc.d --cpu=Cortex-M0 --apcs=interwork -O0 -I.\BSP_lib\Inc\Driver -I.\CMSIS\CMOSupport -I.\CMSIS\NUC1xxSupport -I.\User\inc -I.\modbus\include -I.\modbus\MBport -I.\modbus\rtu -I"D:\Program Files\keil\ARM\RV31\INC" -I"D:\Program Files\keil\ARM\PACK\ARM\CMSIS\3.20.4\CMSIS\Include" -I"D:\Program Files\keil\ARM\Inc\Nuvoton\NUC1xx" --omf_browse=.\obj\mbfuncdisc.crf modbus\functions\mbfuncdisc.c]
                          THUMB

                          AREA ||i.eMBFuncReadDiscreteInputs||, CODE, READONLY, ALIGN=1

                  eMBFuncReadDiscreteInputs PROC
;;;48     eMBException
;;;49     eMBFuncReadDiscreteInputs( UCHAR * pucFrame, USHORT * usLen )
000000  b5f0              PUSH     {r4-r7,lr}
;;;50     {
000002  b085              SUB      sp,sp,#0x14
000004  4606              MOV      r6,r0
000006  460d              MOV      r5,r1
;;;51         USHORT          usRegAddress;
;;;52         USHORT          usDiscreteCnt;
;;;53         UCHAR           ucNBytes;
;;;54         UCHAR          *pucFrameCur;
;;;55     
;;;56         eMBException    eStatus = MB_EX_NONE;
000008  2000              MOVS     r0,#0
00000a  9001              STR      r0,[sp,#4]
;;;57         eMBErrorCode    eRegStatus;
;;;58     
;;;59         if( *usLen == ( MB_PDU_FUNC_READ_SIZE + MB_PDU_SIZE_MIN ) )
00000c  8828              LDRH     r0,[r5,#0]
00000e  2805              CMP      r0,#5
000010  d14d              BNE      |L1.174|
;;;60         {
;;;61             usRegAddress = ( USHORT )( pucFrame[MB_PDU_FUNC_READ_ADDR_OFF] << 8 );
000012  7870              LDRB     r0,[r6,#1]
000014  0200              LSLS     r0,r0,#8
000016  9003              STR      r0,[sp,#0xc]
;;;62             usRegAddress |= ( USHORT )( pucFrame[MB_PDU_FUNC_READ_ADDR_OFF + 1] );
000018  78b0              LDRB     r0,[r6,#2]
00001a  9903              LDR      r1,[sp,#0xc]
00001c  4308              ORRS     r0,r0,r1
00001e  9003              STR      r0,[sp,#0xc]
;;;63             usRegAddress++;
000020  9803              LDR      r0,[sp,#0xc]
000022  1c40              ADDS     r0,r0,#1
000024  b280              UXTH     r0,r0
000026  9003              STR      r0,[sp,#0xc]
;;;64     
;;;65             usDiscreteCnt = ( USHORT )( pucFrame[MB_PDU_FUNC_READ_DISCCNT_OFF] << 8 );
000028  78f0              LDRB     r0,[r6,#3]
00002a  0204              LSLS     r4,r0,#8
;;;66             usDiscreteCnt |= ( USHORT )( pucFrame[MB_PDU_FUNC_READ_DISCCNT_OFF + 1] );
00002c  7930              LDRB     r0,[r6,#4]
00002e  4304              ORRS     r4,r4,r0
;;;67     
;;;68             /* Check if the number of registers to read is valid. If not
;;;69              * return Modbus illegal data value exception. 
;;;70              */
;;;71             if( ( usDiscreteCnt >= 1 ) &&
000030  2c01              CMP      r4,#1
000032  db39              BLT      |L1.168|
;;;72                 ( usDiscreteCnt < MB_PDU_FUNC_READ_DISCCNT_MAX ) )
000034  207d              MOVS     r0,#0x7d
000036  0100              LSLS     r0,r0,#4
000038  4284              CMP      r4,r0
00003a  da35              BGE      |L1.168|
;;;73             {
;;;74                 /* Set the current PDU data pointer to the beginning. */
;;;75                 pucFrameCur = &pucFrame[MB_PDU_FUNC_OFF];
00003c  4637              MOV      r7,r6
;;;76                 *usLen = MB_PDU_FUNC_OFF;
00003e  2000              MOVS     r0,#0
000040  8028              STRH     r0,[r5,#0]
;;;77     
;;;78                 /* First byte contains the function code. */
;;;79                 *pucFrameCur++ = MB_FUNC_READ_DISCRETE_INPUTS;
000042  2002              MOVS     r0,#2
000044  7038              STRB     r0,[r7,#0]
000046  1c7f              ADDS     r7,r7,#1
;;;80                 *usLen += 1;
000048  8828              LDRH     r0,[r5,#0]
00004a  1c40              ADDS     r0,r0,#1
00004c  8028              STRH     r0,[r5,#0]
;;;81     
;;;82                 /* Test if the quantity of coils is a multiple of 8. If not last
;;;83                  * byte is only partially field with unused coils set to zero. */
;;;84                 if( ( usDiscreteCnt & 0x0007 ) != 0 )
00004e  0760              LSLS     r0,r4,#29
000050  0f40              LSRS     r0,r0,#29
000052  2800              CMP      r0,#0
000054  d008              BEQ      |L1.104|
;;;85                 {
;;;86                     ucNBytes = ( UCHAR ) ( usDiscreteCnt / 8 + 1 );
000056  4620              MOV      r0,r4
000058  17e1              ASRS     r1,r4,#31
00005a  0f49              LSRS     r1,r1,#29
00005c  1809              ADDS     r1,r1,r0
00005e  10c9              ASRS     r1,r1,#3
000060  1c49              ADDS     r1,r1,#1
000062  b2c9              UXTB     r1,r1
000064  9102              STR      r1,[sp,#8]
000066  e006              B        |L1.118|
                  |L1.104|
;;;87                 }
;;;88                 else
;;;89                 {
;;;90                     ucNBytes = ( UCHAR ) ( usDiscreteCnt / 8 );
000068  4620              MOV      r0,r4
00006a  17e1              ASRS     r1,r4,#31
00006c  0f49              LSRS     r1,r1,#29
00006e  1809              ADDS     r1,r1,r0
000070  0549              LSLS     r1,r1,#21
000072  0e09              LSRS     r1,r1,#24
000074  9102              STR      r1,[sp,#8]
                  |L1.118|
;;;91                 }
;;;92                 *pucFrameCur++ = ucNBytes;
000076  9802              LDR      r0,[sp,#8]
000078  7038              STRB     r0,[r7,#0]
00007a  1c7f              ADDS     r7,r7,#1
;;;93                 *usLen += 1;
00007c  8828              LDRH     r0,[r5,#0]
00007e  1c40              ADDS     r0,r0,#1
000080  8028              STRH     r0,[r5,#0]
;;;94     
;;;95                 eRegStatus =
000082  4622              MOV      r2,r4
000084  4638              MOV      r0,r7
000086  9903              LDR      r1,[sp,#0xc]
000088  f7fffffe          BL       eMBRegDiscreteCB
00008c  9000              STR      r0,[sp,#0]
;;;96                     eMBRegDiscreteCB( pucFrameCur, usRegAddress, usDiscreteCnt );
;;;97     
;;;98                 /* If an error occured convert it into a Modbus exception. */
;;;99                 if( eRegStatus != MB_ENOERR )
00008e  9800              LDR      r0,[sp,#0]
000090  2800              CMP      r0,#0
000092  d004              BEQ      |L1.158|
;;;100                {
;;;101                    eStatus = prveMBError2Exception( eRegStatus );
000094  9800              LDR      r0,[sp,#0]
000096  f7fffffe          BL       prveMBError2Exception
00009a  9001              STR      r0,[sp,#4]
00009c  e009              B        |L1.178|
                  |L1.158|
;;;102                }
;;;103                else
;;;104                {
;;;105                    /* The response contains the function code, the starting address
;;;106                     * and the quantity of registers. We reuse the old values in the 
;;;107                     * buffer because they are still valid. */
;;;108                    *usLen += ucNBytes;;
00009e  8829              LDRH     r1,[r5,#0]
0000a0  9802              LDR      r0,[sp,#8]
0000a2  1808              ADDS     r0,r1,r0
0000a4  8028              STRH     r0,[r5,#0]
0000a6  e004              B        |L1.178|
                  |L1.168|
;;;109                }
;;;110            }
;;;111            else
;;;112            {
;;;113                eStatus = MB_EX_ILLEGAL_DATA_VALUE;
0000a8  2003              MOVS     r0,#3
0000aa  9001              STR      r0,[sp,#4]
0000ac  e001              B        |L1.178|
                  |L1.174|
;;;114            }
;;;115        }
;;;116        else
;;;117        {
;;;118            /* Can't be a valid read coil register request because the length
;;;119             * is incorrect. */
;;;120            eStatus = MB_EX_ILLEGAL_DATA_VALUE;
0000ae  2003              MOVS     r0,#3
0000b0  9001              STR      r0,[sp,#4]
                  |L1.178|
;;;121        }
;;;122        return eStatus;
0000b2  9801              LDR      r0,[sp,#4]
;;;123    }
0000b4  b005              ADD      sp,sp,#0x14
0000b6  bdf0              POP      {r4-r7,pc}
;;;124    
                          ENDP

