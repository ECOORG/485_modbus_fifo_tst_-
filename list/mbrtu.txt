; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\mbrtu.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\mbrtu.d --cpu=Cortex-M0 --apcs=interwork -O0 -I.\BSP_lib\Inc\Driver -I.\CMSIS\CMOSupport -I.\CMSIS\NUC1xxSupport -I.\User\inc -I.\modbus\include -I.\modbus\MBport -I.\modbus\rtu -I"D:\Program Files\keil\ARM\RV31\INC" -I"D:\Program Files\keil\ARM\PACK\ARM\CMSIS\3.20.4\CMSIS\Include" -I"D:\Program Files\keil\ARM\Inc\Nuvoton\NUC1xx" --omf_browse=.\obj\mbrtu.crf modbus\rtu\mbrtu.c]
                          THUMB

                          AREA ||i.eMBRTUInit||, CODE, READONLY, ALIGN=2

                  eMBRTUInit PROC
;;;80     eMBErrorCode
;;;81     eMBRTUInit( UCHAR ucSlaveAddress, UCHAR ucPort, ULONG ulBaudRate, eMBParity eParity )
000000  b5f8              PUSH     {r3-r7,lr}
;;;82     {
000002  460e              MOV      r6,r1
000004  4615              MOV      r5,r2
000006  461f              MOV      r7,r3
;;;83         eMBErrorCode    eStatus = MB_ENOERR;
000008  2000              MOVS     r0,#0
00000a  9000              STR      r0,[sp,#0]
;;;84         ULONG           usTimerT35_50us;
;;;85     
;;;86         ( void )ucSlaveAddress;
;;;87         ENTER_CRITICAL_SECTION(  );
00000c  f7fffffe          BL       EnterCriticalSection
;;;88     
;;;89         /* Modbus RTU uses 8 Databits. */
;;;90         if( xMBPortSerialInit( ucPort, ulBaudRate, 8, eParity ) != TRUE )
000010  463b              MOV      r3,r7
000012  2208              MOVS     r2,#8
000014  4629              MOV      r1,r5
000016  4630              MOV      r0,r6
000018  f7fffffe          BL       xMBPortSerialInit
00001c  2801              CMP      r0,#1
00001e  d002              BEQ      |L1.38|
;;;91         {
;;;92             eStatus = MB_EPORTERR;
000020  2003              MOVS     r0,#3
000022  9000              STR      r0,[sp,#0]
000024  e016              B        |L1.84|
                  |L1.38|
;;;93         }
;;;94         else
;;;95         {
;;;96             /* If baudrate > 19200 then we should use the fixed timer values
;;;97              * t35 = 1750us. Otherwise t35 must be 3.5 times the character time.
;;;98              */
;;;99             if( ulBaudRate > 19200 )
000026  204b              MOVS     r0,#0x4b
000028  0200              LSLS     r0,r0,#8
00002a  4285              CMP      r5,r0
00002c  d90a              BLS      |L1.68|
;;;100            {
;;;101    //            usTimerT35_50us = 35;       /* 1800us. */
;;;102                /* The timer reload value for a character is given by:
;;;103                 *
;;;104                 * ChTimeValue = 1800 / ( 1000000/Baudrate )
;;;105                 *             = 18 * Baudrate /10000ul
;;;106                 * The reload for t3.5 is 1.5 times this value and similary
;;;107                 * for t3.5.
;;;108                 */
;;;109                usTimerT35_50us = 18ul * ulBaudRate / 10000ul;       /* 1800us. */
00002e  2112              MOVS     r1,#0x12
000030  4369              MULS     r1,r5,r1
000032  4608              MOV      r0,r1
000034  4909              LDR      r1,|L1.92|
000036  f7fffffe          BL       __aeabi_uidivmod
00003a  4604              MOV      r4,r0
;;;110                if(usTimerT35_50us > 255)   usTimerT35_50us = 255;
00003c  2cff              CMP      r4,#0xff
00003e  d902              BLS      |L1.70|
000040  24ff              MOVS     r4,#0xff
000042  e000              B        |L1.70|
                  |L1.68|
;;;111            }
;;;112            else
;;;113            {
;;;114                /* The timer reload value for a character is given by:
;;;115                 *
;;;116                 * ChTimeValue = Ticks_per_1s / ( Baudrate / 11 )
;;;117                 *             = 11 * Ticks_per_1s / Baudrate
;;;118                 *             = 220000 / Baudrate
;;;119                 * The reload for t3.5 is 1.5 times this value and similary
;;;120                 * for t3.5.
;;;121                 */
;;;122    //            usTimerT35_50us = ( 7UL * 220000UL ) / ( 2UL * ulBaudRate );
;;;123                usTimerT35_50us = 4*11;
000044  242c              MOVS     r4,#0x2c
                  |L1.70|
;;;124            }
;;;125            if( xMBPortTimersInit( ( USHORT ) usTimerT35_50us ) != TRUE )
000046  b2a0              UXTH     r0,r4
000048  f7fffffe          BL       xMBPortTimersInit
00004c  2801              CMP      r0,#1
00004e  d001              BEQ      |L1.84|
;;;126            {
;;;127                eStatus = MB_EPORTERR;
000050  2003              MOVS     r0,#3
000052  9000              STR      r0,[sp,#0]
                  |L1.84|
;;;128            }
;;;129        }
;;;130        EXIT_CRITICAL_SECTION(  );
000054  f7fffffe          BL       ExitCriticalSection
;;;131    
;;;132        return eStatus;
000058  9800              LDR      r0,[sp,#0]
;;;133    }
00005a  bdf8              POP      {r3-r7,pc}
;;;134    
                          ENDP

                  |L1.92|
                          DCD      0x00002710

                          AREA ||i.eMBRTUReceive||, CODE, READONLY, ALIGN=2

                  eMBRTUReceive PROC
;;;161    eMBErrorCode
;;;162    eMBRTUReceive( UCHAR * pucRcvAddress, UCHAR ** pucFrame, USHORT * pusLength )
000000  b5f8              PUSH     {r3-r7,lr}
;;;163    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
;;;164        //BOOL            xFrameReceived = FALSE;
;;;165        eMBErrorCode    eStatus = MB_ENOERR;
000008  2700              MOVS     r7,#0
;;;166    
;;;167        ENTER_CRITICAL_SECTION(  );
00000a  f7fffffe          BL       EnterCriticalSection
;;;168        assert( usRcvBufferPos < MB_SER_PDU_SIZE_MAX );
00000e  4812              LDR      r0,|L2.88|
000010  8800              LDRH     r0,[r0,#0]  ; usRcvBufferPos
000012  28ff              CMP      r0,#0xff
000014  dc00              BGT      |L2.24|
000016  e004              B        |L2.34|
                  |L2.24|
000018  22a8              MOVS     r2,#0xa8
00001a  a110              ADR      r1,|L2.92|
00001c  a014              ADR      r0,|L2.112|
00001e  f7fffffe          BL       __aeabi_assert
                  |L2.34|
;;;169    
;;;170        /* Length and CRC check */
;;;171        if( ( usRcvBufferPos >= MB_SER_PDU_SIZE_MIN )
000022  480d              LDR      r0,|L2.88|
000024  8800              LDRH     r0,[r0,#0]  ; usRcvBufferPos
000026  2804              CMP      r0,#4
000028  db11              BLT      |L2.78|
;;;172            && ( usMBCRC16( ( UCHAR * ) ucRTUBuf, usRcvBufferPos ) == 0 ) )
00002a  480b              LDR      r0,|L2.88|
00002c  8801              LDRH     r1,[r0,#0]  ; usRcvBufferPos
00002e  481a              LDR      r0,|L2.152|
000030  f7fffffe          BL       usMBCRC16
000034  2800              CMP      r0,#0
000036  d10a              BNE      |L2.78|
;;;173        {
;;;174            /* Save the address field. All frames are passed to the upper layed
;;;175             * and the decision if a frame is used is done there.
;;;176             */
;;;177            *pucRcvAddress = ucRTUBuf[MB_SER_PDU_ADDR_OFF];
000038  4817              LDR      r0,|L2.152|
00003a  7800              LDRB     r0,[r0,#0]  ; ucRTUBuf
00003c  7020              STRB     r0,[r4,#0]
;;;178    
;;;179            /* Total length of Modbus-PDU is Modbus-Serial-Line-PDU minus
;;;180             * size of address field and CRC checksum.
;;;181             */
;;;182            *pusLength = ( USHORT )( usRcvBufferPos - MB_SER_PDU_PDU_OFF - MB_SER_PDU_SIZE_CRC );
00003e  4806              LDR      r0,|L2.88|
000040  8800              LDRH     r0,[r0,#0]  ; usRcvBufferPos
000042  1ec0              SUBS     r0,r0,#3
000044  8030              STRH     r0,[r6,#0]
;;;183    
;;;184            /* Return the start of the Modbus PDU to the caller. */
;;;185            *pucFrame = ( UCHAR * ) & ucRTUBuf[MB_SER_PDU_PDU_OFF];
000046  4814              LDR      r0,|L2.152|
000048  1c40              ADDS     r0,r0,#1
00004a  6028              STR      r0,[r5,#0]
00004c  e000              B        |L2.80|
                  |L2.78|
;;;186            //xFrameReceived = TRUE;
;;;187        }
;;;188        else
;;;189        {
;;;190            eStatus = MB_EIO;
00004e  2705              MOVS     r7,#5
                  |L2.80|
;;;191        }
;;;192    
;;;193        EXIT_CRITICAL_SECTION(  );
000050  f7fffffe          BL       ExitCriticalSection
;;;194        return eStatus;
000054  4638              MOV      r0,r7
;;;195    }
000056  bdf8              POP      {r3-r7,pc}
;;;196    
                          ENDP

                  |L2.88|
                          DCD      usRcvBufferPos
                  |L2.92|
00005c  6d6f6462          DCB      "modbus\\rtu\\mbrtu.c",0
000060  75735c72
000064  74755c6d
000068  62727475
00006c  2e6300  
00006f  00                DCB      0
                  |L2.112|
000070  75735263          DCB      "usRcvBufferPos < MB_SER_PDU_SIZE_MAX",0
000074  76427566
000078  66657250
00007c  6f73203c
000080  204d425f
000084  5345525f
000088  5044555f
00008c  53495a45
000090  5f4d4158
000094  00      
000095  00                DCB      0
000096  00                DCB      0
000097  00                DCB      0
                  |L2.152|
                          DCD      ucRTUBuf

                          AREA ||i.eMBRTUSend||, CODE, READONLY, ALIGN=2

                  eMBRTUSend PROC
;;;197    eMBErrorCode
;;;198    eMBRTUSend( UCHAR ucSlaveAddress, const UCHAR * pucFrame, USHORT usLength )
000000  b5f8              PUSH     {r3-r7,lr}
;;;199    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
000006  4617              MOV      r7,r2
;;;200        eMBErrorCode    eStatus = MB_ENOERR;
000008  2000              MOVS     r0,#0
00000a  9000              STR      r0,[sp,#0]
;;;201        USHORT          usCRC16;
;;;202    
;;;203        ENTER_CRITICAL_SECTION(  );
00000c  f7fffffe          BL       EnterCriticalSection
;;;204    
;;;205        /* Check if the receiver is still in idle state. If not we where to
;;;206         * slow with processing the received frame and the master sent another
;;;207         * frame on the network. We have to abort sending the frame.
;;;208         */
;;;209        if( eRcvState == STATE_RX_IDLE )
000010  4819              LDR      r0,|L3.120|
000012  7800              LDRB     r0,[r0,#0]  ; eRcvState
000014  2800              CMP      r0,#0
000016  d129              BNE      |L3.108|
;;;210        {
;;;211            /* First byte before the Modbus-PDU is the slave address. */
;;;212            pucSndBufferCur = ( UCHAR * ) pucFrame - 1;
000018  1e70              SUBS     r0,r6,#1
00001a  4918              LDR      r1,|L3.124|
00001c  6008              STR      r0,[r1,#0]  ; pucSndBufferCur
;;;213            usSndBufferCount = 1;
00001e  2001              MOVS     r0,#1
000020  4917              LDR      r1,|L3.128|
000022  8008              STRH     r0,[r1,#0]
;;;214    
;;;215            /* Now copy the Modbus-PDU into the Modbus-Serial-Line-PDU. */
;;;216            pucSndBufferCur[MB_SER_PDU_ADDR_OFF] = ucSlaveAddress;
000024  4815              LDR      r0,|L3.124|
000026  6800              LDR      r0,[r0,#0]  ; pucSndBufferCur
000028  7005              STRB     r5,[r0,#0]
;;;217            usSndBufferCount += usLength;
00002a  4608              MOV      r0,r1
00002c  8800              LDRH     r0,[r0,#0]  ; usSndBufferCount
00002e  19c0              ADDS     r0,r0,r7
000030  8008              STRH     r0,[r1,#0]
;;;218    
;;;219            /* Calculate CRC16 checksum for Modbus-Serial-Line-PDU. */
;;;220            usCRC16 = usMBCRC16( ( UCHAR * ) pucSndBufferCur, usSndBufferCount );
000032  4608              MOV      r0,r1
000034  8801              LDRH     r1,[r0,#0]  ; usSndBufferCount
000036  4811              LDR      r0,|L3.124|
000038  6800              LDR      r0,[r0,#0]  ; pucSndBufferCur
00003a  f7fffffe          BL       usMBCRC16
00003e  4604              MOV      r4,r0
;;;221            ucRTUBuf[usSndBufferCount++] = ( UCHAR )( usCRC16 & 0xFF );
000040  4a0f              LDR      r2,|L3.128|
000042  8810              LDRH     r0,[r2,#0]  ; usSndBufferCount
000044  1c42              ADDS     r2,r0,#1
000046  4b0e              LDR      r3,|L3.128|
000048  801a              STRH     r2,[r3,#0]
00004a  4a0e              LDR      r2,|L3.132|
00004c  5414              STRB     r4,[r2,r0]
;;;222            ucRTUBuf[usSndBufferCount++] = ( UCHAR )( usCRC16 >> 8 );
00004e  1221              ASRS     r1,r4,#8
000050  461a              MOV      r2,r3
000052  8810              LDRH     r0,[r2,#0]  ; usSndBufferCount
000054  1c42              ADDS     r2,r0,#1
000056  801a              STRH     r2,[r3,#0]
000058  4a0a              LDR      r2,|L3.132|
00005a  5411              STRB     r1,[r2,r0]
;;;223    
;;;224            /* Activate the transmitter. */
;;;225            eSndState = STATE_TX_XMIT;
00005c  2001              MOVS     r0,#1
00005e  490a              LDR      r1,|L3.136|
000060  7008              STRB     r0,[r1,#0]
;;;226            vMBPortSerialEnable( FALSE, TRUE );
000062  2101              MOVS     r1,#1
000064  2000              MOVS     r0,#0
000066  f7fffffe          BL       vMBPortSerialEnable
00006a  e001              B        |L3.112|
                  |L3.108|
;;;227        }
;;;228        else
;;;229        {
;;;230            eStatus = MB_EIO;
00006c  2005              MOVS     r0,#5
00006e  9000              STR      r0,[sp,#0]
                  |L3.112|
;;;231        }
;;;232        EXIT_CRITICAL_SECTION(  );
000070  f7fffffe          BL       ExitCriticalSection
;;;233        return eStatus;
000074  9800              LDR      r0,[sp,#0]
;;;234    }
000076  bdf8              POP      {r3-r7,pc}
;;;235    
                          ENDP

                  |L3.120|
                          DCD      eRcvState
                  |L3.124|
                          DCD      pucSndBufferCur
                  |L3.128|
                          DCD      usSndBufferCount
                  |L3.132|
                          DCD      ucRTUBuf
                  |L3.136|
                          DCD      eSndState

                          AREA ||i.eMBRTUStart||, CODE, READONLY, ALIGN=2

                  eMBRTUStart PROC
;;;135    void
;;;136    eMBRTUStart( void )
000000  b510              PUSH     {r4,lr}
;;;137    {
;;;138        ENTER_CRITICAL_SECTION(  );
000002  f7fffffe          BL       EnterCriticalSection
;;;139        /* Initially the receiver is in the state STATE_RX_INIT. we start
;;;140         * the timer and if no character is received within t3.5 we change
;;;141         * to STATE_RX_IDLE. This makes sure that we delay startup of the
;;;142         * modbus protocol stack until the bus is free.
;;;143         */
;;;144        eRcvState = STATE_RX_IDLE;
000006  2000              MOVS     r0,#0
000008  4906              LDR      r1,|L4.36|
00000a  7008              STRB     r0,[r1,#0]
;;;145        xMBPortEventPost( EV_READY );
00000c  f7fffffe          BL       xMBPortEventPost
;;;146        vMBPortSerialEnable( TRUE, FALSE );
000010  2100              MOVS     r1,#0
000012  2001              MOVS     r0,#1
000014  f7fffffe          BL       vMBPortSerialEnable
;;;147        vMBPortTimersEnable(  );
000018  f7fffffe          BL       vMBPortTimersEnable
;;;148    
;;;149        EXIT_CRITICAL_SECTION(  );
00001c  f7fffffe          BL       ExitCriticalSection
;;;150    }
000020  bd10              POP      {r4,pc}
;;;151    
                          ENDP

000022  0000              DCW      0x0000
                  |L4.36|
                          DCD      eRcvState

                          AREA ||i.eMBRTUStop||, CODE, READONLY, ALIGN=1

                  eMBRTUStop PROC
;;;152    void
;;;153    eMBRTUStop( void )
000000  b510              PUSH     {r4,lr}
;;;154    {
;;;155        ENTER_CRITICAL_SECTION(  );
000002  f7fffffe          BL       EnterCriticalSection
;;;156        vMBPortSerialEnable( FALSE, FALSE );
000006  2100              MOVS     r1,#0
000008  4608              MOV      r0,r1
00000a  f7fffffe          BL       vMBPortSerialEnable
;;;157        vMBPortTimersDisable(  );
00000e  f7fffffe          BL       vMBPortTimersDisable
;;;158        EXIT_CRITICAL_SECTION(  );
000012  f7fffffe          BL       ExitCriticalSection
;;;159    }
000016  bd10              POP      {r4,pc}
;;;160    
                          ENDP


                          AREA ||i.xMBRTUReceiveFSM||, CODE, READONLY, ALIGN=2

                  xMBRTUReceiveFSM PROC
;;;236    BOOL
;;;237    xMBRTUReceiveFSM( void )
000000  b510              PUSH     {r4,lr}
;;;238    {
000002  b092              SUB      sp,sp,#0x48
;;;239    //    BOOL            xTaskNeedSwitch = FALSE;
;;;240        UCHAR           ucByte[64],CharCnt,cnt;
;;;241    
;;;242        assert( eSndState == STATE_TX_IDLE );
000004  482b              LDR      r0,|L6.180|
000006  7800              LDRB     r0,[r0,#0]  ; eSndState
000008  2800              CMP      r0,#0
00000a  d100              BNE      |L6.14|
00000c  e004              B        |L6.24|
                  |L6.14|
00000e  22f2              MOVS     r2,#0xf2
000010  a129              ADR      r1,|L6.184|
000012  a02e              ADR      r0,|L6.204|
000014  f7fffffe          BL       __aeabi_assert
                  |L6.24|
;;;243    
;;;244        /* Always read the character. */
;;;245        CharCnt = 0;
000018  2000              MOVS     r0,#0
00001a  9001              STR      r0,[sp,#4]
;;;246        ( void )xMBPortSerialGetByte( ucByte ,&CharCnt);
00001c  a901              ADD      r1,sp,#4
00001e  a802              ADD      r0,sp,#8
000020  f7fffffe          BL       xMBPortSerialGetByte
;;;247    
;;;248        switch ( eRcvState )
000024  4830              LDR      r0,|L6.232|
000026  7800              LDRB     r0,[r0,#0]  ; eRcvState
000028  2800              CMP      r0,#0
00002a  d006              BEQ      |L6.58|
00002c  2801              CMP      r0,#1
00002e  d01e              BEQ      |L6.110|
000030  2802              CMP      r0,#2
000032  d13b              BNE      |L6.172|
;;;249        {
;;;250            /* If we have received a character in the init state we have to
;;;251             * wait until the frame is finished.
;;;252             */
;;;253    //    case STATE_RX_INIT:
;;;254    //        vMBPortTimersEnable(  );
;;;255    //        break;
;;;256    
;;;257            /* In the error state we wait until all characters in the
;;;258             * damaged frame are transmitted.
;;;259             */
;;;260        case STATE_RX_ERROR:
;;;261            vMBPortTimersEnable(  );
000034  f7fffffe          BL       vMBPortTimersEnable
;;;262            break;
000038  e038              B        |L6.172|
                  |L6.58|
;;;263    
;;;264            /* In the idle state we wait for a new character. If a character
;;;265             * is received the t1.5 and t3.5 timers are started and the
;;;266             * receiver is in the state STATE_RX_RECEIVCE.
;;;267             */
;;;268        case STATE_RX_IDLE:
;;;269            usRcvBufferPos = 0;
00003a  2000              MOVS     r0,#0
00003c  492b              LDR      r1,|L6.236|
00003e  8008              STRH     r0,[r1,#0]
;;;270            for(cnt = 0; cnt < CharCnt; cnt++){
000040  2400              MOVS     r4,#0
000042  e00a              B        |L6.90|
                  |L6.68|
;;;271                ucRTUBuf[usRcvBufferPos++] = ucByte[cnt];
000044  a902              ADD      r1,sp,#8
000046  5d0a              LDRB     r2,[r1,r4]
000048  4928              LDR      r1,|L6.236|
00004a  8808              LDRH     r0,[r1,#0]  ; usRcvBufferPos
00004c  1c41              ADDS     r1,r0,#1
00004e  4b27              LDR      r3,|L6.236|
000050  8019              STRH     r1,[r3,#0]
000052  4927              LDR      r1,|L6.240|
000054  540a              STRB     r2,[r1,r0]
000056  1c60              ADDS     r0,r4,#1              ;270
000058  b2c4              UXTB     r4,r0                 ;270
                  |L6.90|
00005a  4668              MOV      r0,sp                 ;270
00005c  7900              LDRB     r0,[r0,#4]            ;270
00005e  4284              CMP      r4,r0                 ;270
000060  dbf0              BLT      |L6.68|
;;;272            }
;;;273            eRcvState = STATE_RX_RCV;
000062  2001              MOVS     r0,#1
000064  4920              LDR      r1,|L6.232|
000066  7008              STRB     r0,[r1,#0]
;;;274    
;;;275            /* Enable t3.5 timers. */
;;;276            vMBPortTimersEnable(  );
000068  f7fffffe          BL       vMBPortTimersEnable
;;;277            break;
00006c  e01e              B        |L6.172|
                  |L6.110|
;;;278    
;;;279            /* We are currently receiving a frame. Reset the timer after
;;;280             * every character received. If more than the maximum possible
;;;281             * number of bytes in a modbus frame is received the frame is
;;;282             * ignored.
;;;283             */
;;;284        case STATE_RX_RCV:
;;;285            if( usRcvBufferPos + CharCnt < MB_SER_PDU_SIZE_MAX )
00006e  481f              LDR      r0,|L6.236|
000070  8800              LDRH     r0,[r0,#0]  ; usRcvBufferPos
000072  4669              MOV      r1,sp
000074  7909              LDRB     r1,[r1,#4]
000076  1840              ADDS     r0,r0,r1
000078  28ff              CMP      r0,#0xff
00007a  dc11              BGT      |L6.160|
;;;286            {
;;;287                for(cnt = 0; cnt < CharCnt; cnt++){
00007c  2400              MOVS     r4,#0
00007e  e00a              B        |L6.150|
                  |L6.128|
;;;288                    ucRTUBuf[usRcvBufferPos++] = ucByte[cnt];
000080  a902              ADD      r1,sp,#8
000082  5d0a              LDRB     r2,[r1,r4]
000084  4919              LDR      r1,|L6.236|
000086  8808              LDRH     r0,[r1,#0]  ; usRcvBufferPos
000088  1c41              ADDS     r1,r0,#1
00008a  4b18              LDR      r3,|L6.236|
00008c  8019              STRH     r1,[r3,#0]
00008e  4918              LDR      r1,|L6.240|
000090  540a              STRB     r2,[r1,r0]
000092  1c60              ADDS     r0,r4,#1              ;287
000094  b2c4              UXTB     r4,r0                 ;287
                  |L6.150|
000096  4668              MOV      r0,sp                 ;287
000098  7900              LDRB     r0,[r0,#4]            ;287
00009a  4284              CMP      r4,r0                 ;287
00009c  dbf0              BLT      |L6.128|
00009e  e002              B        |L6.166|
                  |L6.160|
;;;289                }
;;;290            }
;;;291            else
;;;292            {
;;;293                eRcvState = STATE_RX_ERROR;
0000a0  2002              MOVS     r0,#2
0000a2  4911              LDR      r1,|L6.232|
0000a4  7008              STRB     r0,[r1,#0]
                  |L6.166|
;;;294            }
;;;295            vMBPortTimersEnable(  );
0000a6  f7fffffe          BL       vMBPortTimersEnable
;;;296            break;
0000aa  bf00              NOP      
                  |L6.172|
0000ac  bf00              NOP                            ;262
;;;297        }
;;;298        return 1;
0000ae  2001              MOVS     r0,#1
;;;299    }
0000b0  b012              ADD      sp,sp,#0x48
0000b2  bd10              POP      {r4,pc}
;;;300    
                          ENDP

                  |L6.180|
                          DCD      eSndState
                  |L6.184|
0000b8  6d6f6462          DCB      "modbus\\rtu\\mbrtu.c",0
0000bc  75735c72
0000c0  74755c6d
0000c4  62727475
0000c8  2e6300  
0000cb  00                DCB      0
                  |L6.204|
0000cc  65536e64          DCB      "eSndState == STATE_TX_IDLE",0
0000d0  53746174
0000d4  65203d3d
0000d8  20535441
0000dc  54455f54
0000e0  585f4944
0000e4  4c4500  
0000e7  00                DCB      0
                  |L6.232|
                          DCD      eRcvState
                  |L6.236|
                          DCD      usRcvBufferPos
                  |L6.240|
                          DCD      ucRTUBuf

                          AREA ||i.xMBRTUTimerT35Expired||, CODE, READONLY, ALIGN=2

                  xMBRTUTimerT35Expired PROC
;;;345    BOOL
;;;346    xMBRTUTimerT35Expired( void )
000000  b530              PUSH     {r4,r5,lr}
;;;347    {
000002  b091              SUB      sp,sp,#0x44
;;;348        BOOL            xNeedPoll = FALSE;
000004  2500              MOVS     r5,#0
;;;349    
;;;350        UCHAR           ucByte[64],CharCnt,cnt;
;;;351    
;;;352        /* Always read the character. */
;;;353        CharCnt = 0;
000006  2000              MOVS     r0,#0
000008  9000              STR      r0,[sp,#0]
;;;354        ( void )xMBPortSerialGetByte( ucByte ,&CharCnt);
00000a  4669              MOV      r1,sp
00000c  a801              ADD      r0,sp,#4
00000e  f7fffffe          BL       xMBPortSerialGetByte
;;;355        switch ( eRcvState )
000012  481e              LDR      r0,|L7.140|
000014  7800              LDRB     r0,[r0,#0]  ; eRcvState
000016  2800              CMP      r0,#0
000018  d004              BEQ      |L7.36|
00001a  2801              CMP      r0,#1
00001c  d006              BEQ      |L7.44|
00001e  2802              CMP      r0,#2
000020  d11b              BNE      |L7.90|
000022  e019              B        |L7.88|
                  |L7.36|
;;;356        {
;;;357            /* Timer t35 expired. Startup phase is finished. */
;;;358    //    case STATE_RX_INIT:
;;;359    //        xNeedPoll = xMBPortEventPost( EV_READY );
;;;360    //        break;
;;;361    
;;;362            /* A frame was received and t35 expired. Notify the listener that
;;;363             * a new frame was received. */
;;;364        case STATE_RX_IDLE:
;;;365            usRcvBufferPos = 0;
000024  2000              MOVS     r0,#0
000026  491a              LDR      r1,|L7.144|
000028  8008              STRH     r0,[r1,#0]
;;;366        case STATE_RX_RCV:
00002a  bf00              NOP      
                  |L7.44|
;;;367            for(cnt = 0; cnt < CharCnt; cnt++){
00002c  2400              MOVS     r4,#0
00002e  e00a              B        |L7.70|
                  |L7.48|
;;;368                ucRTUBuf[usRcvBufferPos++] = ucByte[cnt];
000030  a901              ADD      r1,sp,#4
000032  5d0a              LDRB     r2,[r1,r4]
000034  4916              LDR      r1,|L7.144|
000036  8808              LDRH     r0,[r1,#0]  ; usRcvBufferPos
000038  1c41              ADDS     r1,r0,#1
00003a  4b15              LDR      r3,|L7.144|
00003c  8019              STRH     r1,[r3,#0]
00003e  4915              LDR      r1,|L7.148|
000040  540a              STRB     r2,[r1,r0]
000042  1c60              ADDS     r0,r4,#1              ;367
000044  b2c4              UXTB     r4,r0                 ;367
                  |L7.70|
000046  4668              MOV      r0,sp                 ;367
000048  7800              LDRB     r0,[r0,#0]            ;367
00004a  4284              CMP      r4,r0                 ;367
00004c  dbf0              BLT      |L7.48|
;;;369            }
;;;370            xNeedPoll = xMBPortEventPost( EV_FRAME_RECEIVED );
00004e  2001              MOVS     r0,#1
000050  f7fffffe          BL       xMBPortEventPost
000054  4605              MOV      r5,r0
;;;371            break;
000056  e010              B        |L7.122|
                  |L7.88|
;;;372    
;;;373            /* An error occured while receiving the frame. */
;;;374        case STATE_RX_ERROR:
;;;375            break;
000058  e00f              B        |L7.122|
                  |L7.90|
;;;376    
;;;377            /* Function called in an illegal state. */
;;;378        default:
;;;379            assert( //( eRcvState == STATE_RX_INIT ) ||
00005a  480c              LDR      r0,|L7.140|
00005c  7800              LDRB     r0,[r0,#0]  ; eRcvState
00005e  2801              CMP      r0,#1
000060  d003              BEQ      |L7.106|
000062  480a              LDR      r0,|L7.140|
000064  7800              LDRB     r0,[r0,#0]  ; eRcvState
000066  2802              CMP      r0,#2
000068  d100              BNE      |L7.108|
                  |L7.106|
00006a  e005              B        |L7.120|
                  |L7.108|
00006c  22ff              MOVS     r2,#0xff
00006e  327c              ADDS     r2,r2,#0x7c
000070  a109              ADR      r1,|L7.152|
000072  480e              LDR      r0,|L7.172|
000074  f7fffffe          BL       __aeabi_assert
                  |L7.120|
000078  bf00              NOP                            ;355
                  |L7.122|
00007a  bf00              NOP                            ;371
;;;380                    ( eRcvState == STATE_RX_RCV ) || ( eRcvState == STATE_RX_ERROR ) );
;;;381        }
;;;382    
;;;383        vMBPortTimersDisable(  );
00007c  f7fffffe          BL       vMBPortTimersDisable
;;;384        eRcvState = STATE_RX_IDLE;
000080  2000              MOVS     r0,#0
000082  4902              LDR      r1,|L7.140|
000084  7008              STRB     r0,[r1,#0]
;;;385    
;;;386        return xNeedPoll;
000086  4628              MOV      r0,r5
;;;387    }
000088  b011              ADD      sp,sp,#0x44
00008a  bd30              POP      {r4,r5,pc}
                          ENDP

                  |L7.140|
                          DCD      eRcvState
                  |L7.144|
                          DCD      usRcvBufferPos
                  |L7.148|
                          DCD      ucRTUBuf
                  |L7.152|
000098  6d6f6462          DCB      "modbus\\rtu\\mbrtu.c",0
00009c  75735c72
0000a0  74755c6d
0000a4  62727475
0000a8  2e6300  
0000ab  00                DCB      0
                  |L7.172|
                          DCD      ||.conststring||

                          AREA ||i.xMBRTUTransmitFSM||, CODE, READONLY, ALIGN=2

                  xMBRTUTransmitFSM PROC
;;;301    BOOL
;;;302    xMBRTUTransmitFSM( void )
000000  b510              PUSH     {r4,lr}
;;;303    {
;;;304        BOOL            xNeedPoll = FALSE;
000002  2400              MOVS     r4,#0
;;;305    
;;;306        assert( eRcvState == STATE_RX_IDLE );
000004  4824              LDR      r0,|L8.152|
000006  7800              LDRB     r0,[r0,#0]  ; eRcvState
000008  2800              CMP      r0,#0
00000a  d100              BNE      |L8.14|
00000c  e005              B        |L8.26|
                  |L8.14|
00000e  22ff              MOVS     r2,#0xff
000010  3233              ADDS     r2,r2,#0x33
000012  a122              ADR      r1,|L8.156|
000014  a026              ADR      r0,|L8.176|
000016  f7fffffe          BL       __aeabi_assert
                  |L8.26|
;;;307    
;;;308        switch ( eSndState )
00001a  482c              LDR      r0,|L8.204|
00001c  7800              LDRB     r0,[r0,#0]  ; eSndState
00001e  2800              CMP      r0,#0
000020  d002              BEQ      |L8.40|
000022  2801              CMP      r0,#1
000024  d134              BNE      |L8.144|
000026  e004              B        |L8.50|
                  |L8.40|
;;;309        {
;;;310            /* We should not get a transmitter event if the transmitter is in
;;;311             * idle state.  */
;;;312        case STATE_TX_IDLE:
;;;313            /* enable receiver/disable transmitter. */
;;;314            vMBPortSerialEnable( TRUE, FALSE );
000028  2100              MOVS     r1,#0
00002a  2001              MOVS     r0,#1
00002c  f7fffffe          BL       vMBPortSerialEnable
;;;315            break;
000030  e02e              B        |L8.144|
                  |L8.50|
;;;316    
;;;317        case STATE_TX_XMIT:
;;;318            /* check if we are finished. */
;;;319            if( usSndBufferCount != 0 )
000032  4827              LDR      r0,|L8.208|
000034  8800              LDRH     r0,[r0,#0]  ; usSndBufferCount
000036  2800              CMP      r0,#0
000038  d01e              BEQ      |L8.120|
;;;320            {
;;;321                if(usSndBufferCount > 64){
00003a  4825              LDR      r0,|L8.208|
00003c  8800              LDRH     r0,[r0,#0]  ; usSndBufferCount
00003e  2840              CMP      r0,#0x40
000040  dd0f              BLE      |L8.98|
;;;322                    xMBPortSerialPutByte( (char *) pucSndBufferCur ,64 );
000042  2140              MOVS     r1,#0x40
000044  4823              LDR      r0,|L8.212|
000046  6800              LDR      r0,[r0,#0]  ; pucSndBufferCur
000048  f7fffffe          BL       xMBPortSerialPutByte
;;;323                    pucSndBufferCur += 64;  /* next byte in sendbuffer. */
00004c  4821              LDR      r0,|L8.212|
00004e  6800              LDR      r0,[r0,#0]  ; pucSndBufferCur
000050  3040              ADDS     r0,r0,#0x40
000052  4920              LDR      r1,|L8.212|
000054  6008              STR      r0,[r1,#0]  ; pucSndBufferCur
;;;324                    usSndBufferCount-= 64;
000056  481e              LDR      r0,|L8.208|
000058  8800              LDRH     r0,[r0,#0]  ; usSndBufferCount
00005a  3840              SUBS     r0,r0,#0x40
00005c  491c              LDR      r1,|L8.208|
00005e  8008              STRH     r0,[r1,#0]
000060  e015              B        |L8.142|
                  |L8.98|
;;;325                }
;;;326                else{
;;;327                    xMBPortSerialPutByte( (char *) pucSndBufferCur ,usSndBufferCount );
000062  481b              LDR      r0,|L8.208|
000064  8800              LDRH     r0,[r0,#0]  ; usSndBufferCount
000066  b2c1              UXTB     r1,r0
000068  481a              LDR      r0,|L8.212|
00006a  6800              LDR      r0,[r0,#0]  ; pucSndBufferCur
00006c  f7fffffe          BL       xMBPortSerialPutByte
;;;328                    usSndBufferCount = 0;
000070  2000              MOVS     r0,#0
000072  4917              LDR      r1,|L8.208|
000074  8008              STRH     r0,[r1,#0]
000076  e00a              B        |L8.142|
                  |L8.120|
;;;329                }
;;;330            }
;;;331            else
;;;332            {
;;;333                xNeedPoll = xMBPortEventPost( EV_FRAME_SENT );
000078  2003              MOVS     r0,#3
00007a  f7fffffe          BL       xMBPortEventPost
00007e  4604              MOV      r4,r0
;;;334                /* Disable transmitter. This prevents another transmit buffer
;;;335                 * empty interrupt. */
;;;336                vMBPortSerialEnable( TRUE, FALSE );
000080  2100              MOVS     r1,#0
000082  2001              MOVS     r0,#1
000084  f7fffffe          BL       vMBPortSerialEnable
;;;337                eSndState = STATE_TX_IDLE;
000088  2000              MOVS     r0,#0
00008a  4910              LDR      r1,|L8.204|
00008c  7008              STRB     r0,[r1,#0]
                  |L8.142|
;;;338            }
;;;339            break;
00008e  bf00              NOP      
                  |L8.144|
000090  bf00              NOP                            ;315
;;;340        }
;;;341    
;;;342        return xNeedPoll;
000092  4620              MOV      r0,r4
;;;343    }
000094  bd10              POP      {r4,pc}
;;;344    
                          ENDP

000096  0000              DCW      0x0000
                  |L8.152|
                          DCD      eRcvState
                  |L8.156|
00009c  6d6f6462          DCB      "modbus\\rtu\\mbrtu.c",0
0000a0  75735c72
0000a4  74755c6d
0000a8  62727475
0000ac  2e6300  
0000af  00                DCB      0
                  |L8.176|
0000b0  65526376          DCB      "eRcvState == STATE_RX_IDLE",0
0000b4  53746174
0000b8  65203d3d
0000bc  20535441
0000c0  54455f52
0000c4  585f4944
0000c8  4c4500  
0000cb  00                DCB      0
                  |L8.204|
                          DCD      eSndState
                  |L8.208|
                          DCD      usSndBufferCount
                  |L8.212|
                          DCD      pucSndBufferCur

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  ucRTUBuf
                          %        256

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  28206552          DCB      "( eRcvState == STATE_RX_RCV ) || ( eRcvState == STATE_R"
000004  63765374
000008  61746520
00000c  3d3d2053
000010  54415445
000014  5f52585f
000018  52435620
00001c  29207c7c
000020  20282065
000024  52637653
000028  74617465
00002c  203d3d20
000030  53544154
000034  455f52  
000037  585f4552          DCB      "X_ERROR )",0
00003b  524f5220
00003f  2900    

                          AREA ||.data||, DATA, ALIGN=2

                  eSndState
000000  00                DCB      0x00
                  eRcvState
000001  000000            DCB      0x00,0x00,0x00
                  pucSndBufferCur
                          DCD      0x00000000
                  usSndBufferCount
000008  0000              DCB      0x00,0x00
                  usRcvBufferPos
00000a  0000              DCB      0x00,0x00
