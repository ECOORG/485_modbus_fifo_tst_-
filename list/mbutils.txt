; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\mbutils.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\mbutils.d --cpu=Cortex-M0 --apcs=interwork -O0 -I.\BSP_lib\Inc\Driver -I.\CMSIS\CMOSupport -I.\CMSIS\NUC1xxSupport -I.\User\inc -I.\modbus\include -I.\modbus\MBport -I.\modbus\rtu -I"D:\Program Files\keil\ARM\RV31\INC" -I"D:\Program Files\keil\ARM\PACK\ARM\CMSIS\3.20.4\CMSIS\Include" -I"D:\Program Files\keil\ARM\Inc\Nuvoton\NUC1xx" --omf_browse=.\obj\mbutils.crf modbus\functions\mbutils.c]
                          THUMB

                          AREA ||i.prveMBError2Exception||, CODE, READONLY, ALIGN=1

                  prveMBError2Exception PROC
;;;116    eMBException
;;;117    prveMBError2Exception( eMBErrorCode eErrorCode )
000000  4601              MOV      r1,r0
;;;118    {
;;;119        eMBException    eStatus;
;;;120    
;;;121        switch ( eErrorCode )
000002  2900              CMP      r1,#0
000004  d004              BEQ      |L1.16|
000006  2901              CMP      r1,#1
000008  d004              BEQ      |L1.20|
00000a  2907              CMP      r1,#7
00000c  d106              BNE      |L1.28|
00000e  e003              B        |L1.24|
                  |L1.16|
;;;122        {
;;;123            case MB_ENOERR:
;;;124                eStatus = MB_EX_NONE;
000010  2000              MOVS     r0,#0
;;;125                break;
000012  e005              B        |L1.32|
                  |L1.20|
;;;126    
;;;127            case MB_ENOREG:
;;;128                eStatus = MB_EX_ILLEGAL_DATA_ADDRESS;
000014  2002              MOVS     r0,#2
;;;129                break;
000016  e003              B        |L1.32|
                  |L1.24|
;;;130    
;;;131            case MB_ETIMEDOUT:
;;;132                eStatus = MB_EX_SLAVE_BUSY;
000018  2006              MOVS     r0,#6
;;;133                break;
00001a  e001              B        |L1.32|
                  |L1.28|
;;;134    
;;;135            default:
;;;136                eStatus = MB_EX_SLAVE_DEVICE_FAILURE;
00001c  2004              MOVS     r0,#4
;;;137                break;
00001e  bf00              NOP      
                  |L1.32|
000020  bf00              NOP                            ;125
;;;138        }
;;;139    
;;;140        return eStatus;
;;;141    }
000022  4770              BX       lr
                          ENDP


                          AREA ||i.xMBUtilGetBits||, CODE, READONLY, ALIGN=1

                  xMBUtilGetBits PROC
;;;85     UCHAR
;;;86     xMBUtilGetBits( UCHAR * ucByteBuf, USHORT usBitOffset, UCHAR ucNBits )
000000  b5f0              PUSH     {r4-r7,lr}
;;;87     {
000002  4603              MOV      r3,r0
000004  460c              MOV      r4,r1
000006  4615              MOV      r5,r2
;;;88         USHORT          usWordBuf;
;;;89         USHORT          usMask;
;;;90         USHORT          usByteOffset;
;;;91         USHORT          usNPreBits;
;;;92     
;;;93         /* Calculate byte offset for first byte containing the bit values starting
;;;94          * at usBitOffset. */
;;;95         usByteOffset = ( USHORT )( ( usBitOffset ) / BITS_UCHAR );
000008  08e2              LSRS     r2,r4,#3
;;;96     
;;;97         /* How many bits precede our bits to set. */
;;;98         usNPreBits = ( USHORT )( usBitOffset - usByteOffset * BITS_UCHAR );
00000a  00d0              LSLS     r0,r2,#3
00000c  1a20              SUBS     r0,r4,r0
00000e  b287              UXTH     r7,r0
;;;99     
;;;100        /* Prepare a mask for setting the new bits. */
;;;101        usMask = ( USHORT )( ( 1 << ( USHORT ) ucNBits ) - 1 );
000010  2001              MOVS     r0,#1
000012  40a8              LSLS     r0,r0,r5
000014  1e40              SUBS     r0,r0,#1
000016  b286              UXTH     r6,r0
;;;102    
;;;103        /* copy bits into temporary storage. */
;;;104        usWordBuf = ucByteBuf[usByteOffset];
000018  5c99              LDRB     r1,[r3,r2]
;;;105        usWordBuf |= ucByteBuf[usByteOffset + 1] << BITS_UCHAR;
00001a  1c50              ADDS     r0,r2,#1
00001c  5c18              LDRB     r0,[r3,r0]
00001e  0200              LSLS     r0,r0,#8
000020  4301              ORRS     r1,r1,r0
;;;106    
;;;107        /* throw away unneeded bits. */
;;;108        usWordBuf >>= usNPreBits;
000022  4608              MOV      r0,r1
000024  4138              ASRS     r0,r0,r7
000026  4601              MOV      r1,r0
;;;109    
;;;110        /* mask away bits above the requested bitfield. */
;;;111        usWordBuf &= usMask;
000028  4608              MOV      r0,r1
00002a  4030              ANDS     r0,r0,r6
00002c  4601              MOV      r1,r0
;;;112    
;;;113        return ( UCHAR ) usWordBuf;
00002e  b2c8              UXTB     r0,r1
;;;114    }
000030  bdf0              POP      {r4-r7,pc}
;;;115    
                          ENDP


                          AREA ||i.xMBUtilSetBits||, CODE, READONLY, ALIGN=2

                  xMBUtilSetBits PROC
;;;46     void
;;;47     xMBUtilSetBits( UCHAR * ucByteBuf, USHORT usBitOffset, UCHAR ucNBits,
000000  b5ff              PUSH     {r0-r7,lr}
;;;48                     UCHAR ucValue )
;;;49     {
000002  b083              SUB      sp,sp,#0xc
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
;;;50         USHORT          usWordBuf;
;;;51         USHORT          usMask;
;;;52         USHORT          usByteOffset;
;;;53         USHORT          usNPreBits;
;;;54         USHORT          usValue = ucValue;
000008  9806              LDR      r0,[sp,#0x18]
00000a  9000              STR      r0,[sp,#0]
;;;55     
;;;56         assert( ucNBits <= 8 );
00000c  9805              LDR      r0,[sp,#0x14]
00000e  2808              CMP      r0,#8
000010  dc00              BGT      |L3.20|
000012  e004              B        |L3.30|
                  |L3.20|
000014  2238              MOVS     r2,#0x38
000016  a115              ADR      r1,|L3.108|
000018  a01b              ADR      r0,|L3.136|
00001a  f7fffffe          BL       __aeabi_assert
                  |L3.30|
;;;57         assert( ( size_t )BITS_UCHAR == sizeof( UCHAR ) * 8 );
;;;58     
;;;59         /* Calculate byte offset for first byte containing the bit values starting
;;;60          * at usBitOffset. */
;;;61         usByteOffset = ( USHORT )( ( usBitOffset ) / BITS_UCHAR );
00001e  08f4              LSRS     r4,r6,#3
;;;62     
;;;63         /* How many bits precede our bits to set. */
;;;64         usNPreBits = ( USHORT )( usBitOffset - usByteOffset * BITS_UCHAR );
000020  00e0              LSLS     r0,r4,#3
000022  1a30              SUBS     r0,r6,r0
000024  b281              UXTH     r1,r0
000026  9101              STR      r1,[sp,#4]
;;;65     
;;;66         /* Move bit field into position over bits to set */
;;;67         usValue <<= usNPreBits;
000028  9901              LDR      r1,[sp,#4]
00002a  9800              LDR      r0,[sp,#0]
00002c  4088              LSLS     r0,r0,r1
00002e  b280              UXTH     r0,r0
000030  9000              STR      r0,[sp,#0]
;;;68     
;;;69         /* Prepare a mask for setting the new bits. */
;;;70         usMask = ( USHORT )( ( 1 << ( USHORT ) ucNBits ) - 1 );
000032  2001              MOVS     r0,#1
000034  9905              LDR      r1,[sp,#0x14]
000036  4088              LSLS     r0,r0,r1
000038  1e40              SUBS     r0,r0,#1
00003a  b280              UXTH     r0,r0
00003c  9002              STR      r0,[sp,#8]
;;;71         usMask <<= usBitOffset - usByteOffset * BITS_UCHAR;
00003e  00e0              LSLS     r0,r4,#3
000040  1a31              SUBS     r1,r6,r0
000042  9802              LDR      r0,[sp,#8]
000044  4088              LSLS     r0,r0,r1
000046  b280              UXTH     r0,r0
000048  9002              STR      r0,[sp,#8]
;;;72     
;;;73         /* copy bits into temporary storage. */
;;;74         usWordBuf = ucByteBuf[usByteOffset];
00004a  5d2f              LDRB     r7,[r5,r4]
;;;75         usWordBuf |= ucByteBuf[usByteOffset + 1] << BITS_UCHAR;
00004c  1c60              ADDS     r0,r4,#1
00004e  5c28              LDRB     r0,[r5,r0]
000050  0200              LSLS     r0,r0,#8
000052  4307              ORRS     r7,r7,r0
;;;76     
;;;77         /* Zero out bit field bits and then or value bits into them. */
;;;78         usWordBuf = ( USHORT )( ( usWordBuf & ( ~usMask ) ) | usValue );
000054  4638              MOV      r0,r7
000056  9902              LDR      r1,[sp,#8]
000058  4388              BICS     r0,r0,r1
00005a  9900              LDR      r1,[sp,#0]
00005c  4308              ORRS     r0,r0,r1
00005e  4607              MOV      r7,r0
;;;79     
;;;80         /* move bits back into storage */
;;;81         ucByteBuf[usByteOffset] = ( UCHAR )( usWordBuf & 0xFF );
000060  552f              STRB     r7,[r5,r4]
;;;82         ucByteBuf[usByteOffset + 1] = ( UCHAR )( usWordBuf >> BITS_UCHAR );
000062  1239              ASRS     r1,r7,#8
000064  1c60              ADDS     r0,r4,#1
000066  5429              STRB     r1,[r5,r0]
;;;83     }
000068  b007              ADD      sp,sp,#0x1c
00006a  bdf0              POP      {r4-r7,pc}
;;;84     
                          ENDP

                  |L3.108|
00006c  6d6f6462          DCB      "modbus\\functions\\mbutils.c",0
000070  75735c66
000074  756e6374
000078  696f6e73
00007c  5c6d6275
000080  74696c73
000084  2e6300  
000087  00                DCB      0
                  |L3.136|
000088  75634e42          DCB      "ucNBits <= 8",0
00008c  69747320
000090  3c3d2038
000094  00      
000095  00                DCB      0
000096  00                DCB      0
000097  00                DCB      0
