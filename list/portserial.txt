; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\portserial.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\portserial.d --cpu=Cortex-M0 --apcs=interwork -O0 -I.\BSP_lib\Inc\Driver -I.\CMSIS\CMOSupport -I.\CMSIS\NUC1xxSupport -I.\User\inc -I.\modbus\include -I.\modbus\MBport -I.\modbus\rtu -I"D:\Program Files\keil\ARM\RV31\INC" -I"D:\Program Files\keil\ARM\PACK\ARM\CMSIS\3.20.4\CMSIS\Include" -I"D:\Program Files\keil\ARM\Inc\Nuvoton\NUC1xx" --omf_browse=.\obj\portserial.crf modbus\MBport\portserial.c]
                          THUMB

                          AREA ||i.Rs485SendChar||, CODE, READONLY, ALIGN=2

                  Rs485SendChar PROC
;;;166    
;;;167    u8bit Rs485SendChar(u8bit ch)
000000  bf00              NOP      
                  |L1.2|
;;;168    {
;;;169        while (UART0->FSR.TE_FLAG !=1);
000002  4904              LDR      r1,|L1.20|
000004  6989              LDR      r1,[r1,#0x18]
000006  00c9              LSLS     r1,r1,#3
000008  0fc9              LSRS     r1,r1,#31
00000a  2900              CMP      r1,#0
00000c  d0f9              BEQ      |L1.2|
;;;170        UART0->DATA = ch;                                       /* Send UART Data from buffer */
00000e  4901              LDR      r1,|L1.20|
000010  6008              STR      r0,[r1,#0]
;;;171        return ch;
;;;172    }
000012  4770              BX       lr
;;;173    void Rs485sPrint(u8bit *Str)
                          ENDP

                  |L1.20|
                          DCD      0x40050000

                          AREA ||i.Rs485sPrint||, CODE, READONLY, ALIGN=1

                  Rs485sPrint PROC
;;;172    }
;;;173    void Rs485sPrint(u8bit *Str)
000000  b500              PUSH     {lr}
;;;174    {
000002  4602              MOV      r2,r0
;;;175        while(*Str){
000004  e003              B        |L2.14|
                  |L2.6|
;;;176            Rs485SendChar(*Str);
000006  7810              LDRB     r0,[r2,#0]
000008  f7fffffe          BL       Rs485SendChar
;;;177            Str++;
00000c  1c52              ADDS     r2,r2,#1
                  |L2.14|
00000e  7810              LDRB     r0,[r2,#0]            ;175
000010  2800              CMP      r0,#0                 ;175
000012  d1f8              BNE      |L2.6|
;;;178        }
;;;179    }
000014  bd00              POP      {pc}
                          ENDP


                          AREA ||i.UART0Handler||, CODE, READONLY, ALIGN=2

                  UART0Handler PROC
;;;119    static void
;;;120    UART0Handler(u32bit Uart0IntStatus)
000000  b510              PUSH     {r4,lr}
;;;121    {   
000002  4604              MOV      r4,r0
;;;122        if(UART0->ISR.RLS_INT){                                 //清楚RLS中断标志
000004  4823              LDR      r0,|L3.148|
000006  69c0              LDR      r0,[r0,#0x1c]
000008  0540              LSLS     r0,r0,#21
00000a  0fc0              LSRS     r0,r0,#31
00000c  2800              CMP      r0,#0
00000e  d026              BEQ      |L3.94|
;;;123            if(UART0->FSR.BIF)  UART0->FSR.BIF = 1;
000010  4820              LDR      r0,|L3.148|
000012  6980              LDR      r0,[r0,#0x18]
000014  0640              LSLS     r0,r0,#25
000016  0fc0              LSRS     r0,r0,#31
000018  2800              CMP      r0,#0
00001a  d006              BEQ      |L3.42|
00001c  481d              LDR      r0,|L3.148|
00001e  6980              LDR      r0,[r0,#0x18]
000020  2140              MOVS     r1,#0x40
000022  4388              BICS     r0,r0,r1
000024  3040              ADDS     r0,r0,#0x40
000026  491b              LDR      r1,|L3.148|
000028  6188              STR      r0,[r1,#0x18]
                  |L3.42|
;;;124            if(UART0->FSR.FEF)  UART0->FSR.FEF = 1;
00002a  481a              LDR      r0,|L3.148|
00002c  6980              LDR      r0,[r0,#0x18]
00002e  0680              LSLS     r0,r0,#26
000030  0fc0              LSRS     r0,r0,#31
000032  2800              CMP      r0,#0
000034  d006              BEQ      |L3.68|
000036  4817              LDR      r0,|L3.148|
000038  6980              LDR      r0,[r0,#0x18]
00003a  2120              MOVS     r1,#0x20
00003c  4388              BICS     r0,r0,r1
00003e  3020              ADDS     r0,r0,#0x20
000040  4914              LDR      r1,|L3.148|
000042  6188              STR      r0,[r1,#0x18]
                  |L3.68|
;;;125            if(UART0->FSR.PEF)  UART0->FSR.PEF = 1;
000044  4813              LDR      r0,|L3.148|
000046  6980              LDR      r0,[r0,#0x18]
000048  06c0              LSLS     r0,r0,#27
00004a  0fc0              LSRS     r0,r0,#31
00004c  2800              CMP      r0,#0
00004e  d006              BEQ      |L3.94|
000050  4810              LDR      r0,|L3.148|
000052  6980              LDR      r0,[r0,#0x18]
000054  2110              MOVS     r1,#0x10
000056  4388              BICS     r0,r0,r1
000058  3010              ADDS     r0,r0,#0x10
00005a  490e              LDR      r1,|L3.148|
00005c  6188              STR      r0,[r1,#0x18]
                  |L3.94|
;;;126        }
;;;127        if(UART0->ISR.TOUT_INT){
00005e  480d              LDR      r0,|L3.148|
000060  69c0              LDR      r0,[r0,#0x1c]
000062  04c0              LSLS     r0,r0,#19
000064  0fc0              LSRS     r0,r0,#31
000066  2800              CMP      r0,#0
000068  d002              BEQ      |L3.112|
;;;128            (void)pxMBPortCBTimerExpired();
00006a  480b              LDR      r0,|L3.152|
00006c  6800              LDR      r0,[r0,#0]  ; pxMBPortCBTimerExpired
00006e  4780              BLX      r0
                  |L3.112|
;;;129        }
;;;130        if(UART0->ISR.RDA_INT){
000070  4808              LDR      r0,|L3.148|
000072  69c0              LDR      r0,[r0,#0x1c]
000074  05c0              LSLS     r0,r0,#23
000076  0fc0              LSRS     r0,r0,#31
000078  2800              CMP      r0,#0
00007a  d001              BEQ      |L3.128|
;;;131            prvvUARTRxISR();
00007c  f7fffffe          BL       prvvUARTRxISR
                  |L3.128|
;;;132        }
;;;133        if(UART0->ISR.THRE_INT){
000080  4804              LDR      r0,|L3.148|
000082  69c0              LDR      r0,[r0,#0x1c]
000084  0580              LSLS     r0,r0,#22
000086  0fc0              LSRS     r0,r0,#31
000088  2800              CMP      r0,#0
00008a  d001              BEQ      |L3.144|
;;;134            prvvUARTTxReadyISR();
00008c  f7fffffe          BL       prvvUARTTxReadyISR
                  |L3.144|
;;;135        }
;;;136    }
000090  bd10              POP      {r4,pc}
;;;137    
                          ENDP

000092  0000              DCW      0x0000
                  |L3.148|
                          DCD      0x40050000
                  |L3.152|
                          DCD      pxMBPortCBTimerExpired

                          AREA ||i.prvvUARTRxISR||, CODE, READONLY, ALIGN=2

                  prvvUARTRxISR PROC
;;;159    static void
;;;160    prvvUARTRxISR(void)
000000  b510              PUSH     {r4,lr}
;;;161    {
;;;162        pxMBFrameCBByteReceived();
000002  4802              LDR      r0,|L4.12|
000004  6800              LDR      r0,[r0,#0]  ; pxMBFrameCBByteReceived
000006  4780              BLX      r0
;;;163    }
000008  bd10              POP      {r4,pc}
;;;164    
                          ENDP

00000a  0000              DCW      0x0000
                  |L4.12|
                          DCD      pxMBFrameCBByteReceived

                          AREA ||i.prvvUARTTxReadyISR||, CODE, READONLY, ALIGN=2

                  prvvUARTTxReadyISR PROC
;;;147    static void
;;;148    prvvUARTTxReadyISR(void)
000000  b510              PUSH     {r4,lr}
;;;149    {
;;;150        pxMBFrameCBTransmitterEmpty();
000002  4802              LDR      r0,|L5.12|
000004  6800              LDR      r0,[r0,#0]  ; pxMBFrameCBTransmitterEmpty
000006  4780              BLX      r0
;;;151    }
000008  bd10              POP      {r4,pc}
;;;152    
                          ENDP

00000a  0000              DCW      0x0000
                  |L5.12|
                          DCD      pxMBFrameCBTransmitterEmpty

                          AREA ||i.vMBPortClose||, CODE, READONLY, ALIGN=1

                  vMBPortClose PROC
;;;33     void
;;;34     vMBPortClose( void )
000000  4770              BX       lr
;;;35     {
;;;36     }
;;;37     
                          ENDP


                          AREA ||i.vMBPortSerialEnable||, CODE, READONLY, ALIGN=2

                  vMBPortSerialEnable PROC
;;;15     void
;;;16     vMBPortSerialEnable( BOOL xRxEnable, BOOL xTxEnable )
000000  b570              PUSH     {r4-r6,lr}
;;;17     {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;18         if(xRxEnable){
000006  2c00              CMP      r4,#0
000008  d007              BEQ      |L7.26|
;;;19             UART0->IER.RDA_IEN = 1;
00000a  4810              LDR      r0,|L7.76|
00000c  6840              LDR      r0,[r0,#4]
00000e  0840              LSRS     r0,r0,#1
000010  0040              LSLS     r0,r0,#1
000012  1c40              ADDS     r0,r0,#1
000014  490d              LDR      r1,|L7.76|
000016  6048              STR      r0,[r1,#4]
000018  e005              B        |L7.38|
                  |L7.26|
;;;20         }
;;;21         else{
;;;22             UART0->IER.RDA_IEN = 0;
00001a  480c              LDR      r0,|L7.76|
00001c  6840              LDR      r0,[r0,#4]
00001e  0840              LSRS     r0,r0,#1
000020  0040              LSLS     r0,r0,#1
000022  490a              LDR      r1,|L7.76|
000024  6048              STR      r0,[r1,#4]
                  |L7.38|
;;;23         }
;;;24         if(xTxEnable){
000026  2d00              CMP      r5,#0
000028  d009              BEQ      |L7.62|
;;;25             UART0->IER.THRE_IEN = 1;
00002a  4808              LDR      r0,|L7.76|
00002c  6840              LDR      r0,[r0,#4]
00002e  2102              MOVS     r1,#2
000030  4388              BICS     r0,r0,r1
000032  1c80              ADDS     r0,r0,#2
000034  4905              LDR      r1,|L7.76|
000036  6048              STR      r0,[r1,#4]
;;;26             prvvUARTTxReadyISR();
000038  f7fffffe          BL       prvvUARTTxReadyISR
00003c  e005              B        |L7.74|
                  |L7.62|
;;;27         }
;;;28         else{
;;;29             UART0->IER.THRE_IEN = 0;
00003e  4803              LDR      r0,|L7.76|
000040  6840              LDR      r0,[r0,#4]
000042  2102              MOVS     r1,#2
000044  4388              BICS     r0,r0,r1
000046  4901              LDR      r1,|L7.76|
000048  6048              STR      r0,[r1,#4]
                  |L7.74|
;;;30         }
;;;31     }
00004a  bd70              POP      {r4-r6,pc}
;;;32     
                          ENDP

                  |L7.76|
                          DCD      0x40050000

                          AREA ||i.xMBPortSerialGetByte||, CODE, READONLY, ALIGN=2

                  xMBPortSerialGetByte PROC
;;;108    BOOL
;;;109    xMBPortSerialGetByte( UCHAR * pucByte , UCHAR * cnt)
000000  4602              MOV      r2,r0
;;;110    {
;;;111        while(UART0->FSR.RX_POINTER){
000002  e006              B        |L8.18|
                  |L8.4|
;;;112            (*cnt)++;
000004  7808              LDRB     r0,[r1,#0]
000006  1c40              ADDS     r0,r0,#1
000008  7008              STRB     r0,[r1,#0]
;;;113            *pucByte = UART0->DATA;
00000a  4806              LDR      r0,|L8.36|
00000c  6800              LDR      r0,[r0,#0]
00000e  7010              STRB     r0,[r2,#0]
;;;114            pucByte++;
000010  1c52              ADDS     r2,r2,#1
                  |L8.18|
000012  4804              LDR      r0,|L8.36|
000014  6980              LDR      r0,[r0,#0x18]         ;111
000016  0480              LSLS     r0,r0,#18             ;111
000018  0e80              LSRS     r0,r0,#26             ;111
00001a  2800              CMP      r0,#0                 ;111
00001c  d1f2              BNE      |L8.4|
;;;115        }
;;;116        return TRUE;
00001e  2001              MOVS     r0,#1
;;;117    }
000020  4770              BX       lr
;;;118    
                          ENDP

000022  0000              DCW      0x0000
                  |L8.36|
                          DCD      0x40050000

                          AREA ||i.xMBPortSerialInit||, CODE, READONLY, ALIGN=2

                  xMBPortSerialInit PROC
;;;38     BOOL
;;;39     xMBPortSerialInit( UCHAR ucPORT, ULONG ulBaudRate, UCHAR ucDataBits, eMBParity eParity )
000000  b5f0              PUSH     {r4-r7,lr}
;;;40     {
000002  b087              SUB      sp,sp,#0x1c
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
000008  4616              MOV      r6,r2
00000a  461f              MOV      r7,r3
;;;41         BOOL            bInitialized = TRUE;
00000c  2001              MOVS     r0,#1
00000e  9006              STR      r0,[sp,#0x18]
;;;42         STR_RS485_T     RS485FnPara;
;;;43         STR_UART_T      Uart0Param;
;;;44     
;;;45         ucPORT = ucPORT;                                        //清楚为使用报警.
000010  bf00              NOP      
;;;46         switch (ucDataBits){                                    //配置数据位长度,该移植默认使用8位数据位
000012  2e08              CMP      r6,#8
000014  d100              BNE      |L9.24|
;;;47         case 8:
;;;48             break;
000016  e002              B        |L9.30|
                  |L9.24|
;;;49         default:
;;;50             bInitialized = FALSE;
000018  2000              MOVS     r0,#0
00001a  9006              STR      r0,[sp,#0x18]
00001c  bf00              NOP                            ;46
                  |L9.30|
00001e  bf00              NOP                            ;48
;;;51         }
;;;52         Uart0Param.u32BaudRate = ulBaudRate;                        //配置波特率
000020  9501              STR      r5,[sp,#4]
;;;53         switch(eParity){                                            //配置字节格式
000022  2f00              CMP      r7,#0
000024  d013              BEQ      |L9.78|
000026  2f01              CMP      r7,#1
000028  d009              BEQ      |L9.62|
00002a  2f02              CMP      r7,#2
00002c  d117              BNE      |L9.94|
;;;54             case MB_PAR_EVEN:                                       //偶校验
;;;55                 Uart0Param.u8cDataBits      = DRVUART_DATABITS_8;   //8位数据位
00002e  2103              MOVS     r1,#3
000030  4668              MOV      r0,sp
000032  7201              STRB     r1,[r0,#8]
;;;56                 Uart0Param.u8cStopBits      = DRVUART_STOPBITS_1;   //1位停止位
000034  2100              MOVS     r1,#0
000036  7241              STRB     r1,[r0,#9]
;;;57                 Uart0Param.u8cParity        = DRVUART_PARITY_EVEN;  //偶校验
000038  2103              MOVS     r1,#3
00003a  7281              STRB     r1,[r0,#0xa]
;;;58                 break;
00003c  e017              B        |L9.110|
                  |L9.62|
;;;59             case MB_PAR_ODD:                                        //奇校验
;;;60                 Uart0Param.u8cDataBits      = DRVUART_DATABITS_8;   //8位数据位
00003e  2103              MOVS     r1,#3
000040  4668              MOV      r0,sp
000042  7201              STRB     r1,[r0,#8]
;;;61                 Uart0Param.u8cStopBits      = DRVUART_STOPBITS_1;   //1位停止位
000044  2100              MOVS     r1,#0
000046  7241              STRB     r1,[r0,#9]
;;;62                 Uart0Param.u8cParity        = DRVUART_PARITY_ODD;   //奇校验
000048  2101              MOVS     r1,#1
00004a  7281              STRB     r1,[r0,#0xa]
;;;63                 break;
00004c  e00f              B        |L9.110|
                  |L9.78|
;;;64             case MB_PAR_NONE:                                       //无校验
;;;65                 Uart0Param.u8cDataBits      = DRVUART_DATABITS_8;   //8位数据位
00004e  2103              MOVS     r1,#3
000050  4668              MOV      r0,sp
000052  7201              STRB     r1,[r0,#8]
;;;66                 Uart0Param.u8cStopBits      = DRVUART_STOPBITS_2;   //2位停止位
000054  2101              MOVS     r1,#1
000056  7241              STRB     r1,[r0,#9]
;;;67                 Uart0Param.u8cParity        = DRVUART_PARITY_NONE;  //无校验
000058  2100              MOVS     r1,#0
00005a  7281              STRB     r1,[r0,#0xa]
;;;68                 break;
00005c  e007              B        |L9.110|
                  |L9.94|
;;;69             default:                                                //偶校验
;;;70                 Uart0Param.u8cDataBits      = DRVUART_DATABITS_8;   //8位数据位
00005e  2103              MOVS     r1,#3
000060  4668              MOV      r0,sp
000062  7201              STRB     r1,[r0,#8]
;;;71                 Uart0Param.u8cStopBits      = DRVUART_STOPBITS_1;   //1位停止位
000064  2100              MOVS     r1,#0
000066  7241              STRB     r1,[r0,#9]
;;;72                 Uart0Param.u8cParity        = DRVUART_PARITY_EVEN;  //偶校验
000068  2103              MOVS     r1,#3
00006a  7281              STRB     r1,[r0,#0xa]
;;;73                 break;
00006c  bf00              NOP      
                  |L9.110|
00006e  bf00              NOP                            ;58
;;;74         }
;;;75         Uart0Param.u8cRxTriggerLevel= DRVUART_FIFO_46BYTES;          //配置接收缓冲区长度
000070  2005              MOVS     r0,#5
000072  4669              MOV      r1,sp
000074  72c8              STRB     r0,[r1,#0xb]
;;;76     //    Uart0Param.u8TimeOut = 0x7f;                                //配置TIMEOUT时间
;;;77         if(bInitialized){                                           //初始化串口
000076  9806              LDR      r0,[sp,#0x18]
000078  2800              CMP      r0,#0
00007a  d01d              BEQ      |L9.184|
;;;78             DrvUART_Open(UART_PORT0, &Uart0Param);
00007c  a901              ADD      r1,sp,#4
00007e  2000              MOVS     r0,#0
000080  f7fffffe          BL       DrvUART_Open
;;;79             UART0->MCR.LEV_RTS = 0;
000084  480e              LDR      r0,|L9.192|
000086  6900              LDR      r0,[r0,#0x10]
000088  2101              MOVS     r1,#1
00008a  0249              LSLS     r1,r1,#9
00008c  4388              BICS     r0,r0,r1
00008e  490c              LDR      r1,|L9.192|
000090  6108              STR      r0,[r1,#0x10]
;;;80             RS485FnPara.u8cAddrEnable = 0;
000092  2100              MOVS     r1,#0
000094  4668              MOV      r0,sp
000096  7441              STRB     r1,[r0,#0x11]
;;;81             RS485FnPara.u8cAddrValue = 0;
000098  7481              STRB     r1,[r0,#0x12]
;;;82             RS485FnPara.u8cDelayTime = 2;
00009a  2102              MOVS     r1,#2
00009c  74c1              STRB     r1,[r0,#0x13]
;;;83             RS485FnPara.u8cModeSelect = MODE_RS485_AUD;             //自动方向识别
00009e  2104              MOVS     r1,#4
0000a0  7401              STRB     r1,[r0,#0x10]
;;;84             RS485FnPara.u8cRxDisable = 0;
0000a2  2100              MOVS     r1,#0
0000a4  7501              STRB     r1,[r0,#0x14]
;;;85             DrvUART_SetFnRS485(UART_PORT0,&RS485FnPara);
0000a6  a904              ADD      r1,sp,#0x10
0000a8  2000              MOVS     r0,#0
0000aa  f7fffffe          BL       DrvUART_SetFnRS485
;;;86             DrvUART_EnableInt(  UART_PORT0,                         //使能以下中断
0000ae  4a05              LDR      r2,|L9.196|
0000b0  2110              MOVS     r1,#0x10
0000b2  2000              MOVS     r0,#0
0000b4  f7fffffe          BL       DrvUART_EnableInt
                  |L9.184|
;;;87                                 //DRVUART_THREINT|                  //发送保持寄存器空中断
;;;88                                 //DRVUART_RLSINT |                  //线上接收中断,检测BIF,FEF,PEF
;;;89                                 DRVUART_TOUTINT|                  //接收数据超时中断
;;;90                                 //DRVUART_RDAINT,                   //接收数据可用中断
;;;91                                 0,
;;;92                                 (PFN_DRVUART_CALLBACK*)UART0Handler);
;;;93         }
;;;94         return bInitialized;
0000b8  9806              LDR      r0,[sp,#0x18]
;;;95     }
0000ba  b007              ADD      sp,sp,#0x1c
0000bc  bdf0              POP      {r4-r7,pc}
;;;96     
                          ENDP

0000be  0000              DCW      0x0000
                  |L9.192|
                          DCD      0x40050000
                  |L9.196|
                          DCD      UART0Handler

                          AREA ||i.xMBPortSerialPutByte||, CODE, READONLY, ALIGN=2

                  xMBPortSerialPutByte PROC
;;;97     BOOL
;;;98     xMBPortSerialPutByte( CHAR *ucByte , UCHAR cnt)
000000  4602              MOV      r2,r0
;;;99     {
;;;100        while(cnt){
000002  e005              B        |L10.16|
                  |L10.4|
;;;101            UART0->DATA = *ucByte;
000004  7810              LDRB     r0,[r2,#0]
000006  4b04              LDR      r3,|L10.24|
000008  6018              STR      r0,[r3,#0]
;;;102            cnt --;
00000a  1e48              SUBS     r0,r1,#1
00000c  b2c1              UXTB     r1,r0
;;;103            ucByte ++;
00000e  1c52              ADDS     r2,r2,#1
                  |L10.16|
000010  2900              CMP      r1,#0                 ;100
000012  d1f7              BNE      |L10.4|
;;;104        }
;;;105        return TRUE;
000014  2001              MOVS     r0,#1
;;;106    }
000016  4770              BX       lr
;;;107    
                          ENDP

                  |L10.24|
                          DCD      0x40050000
