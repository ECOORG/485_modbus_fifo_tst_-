; generated by Component: ARM Compiler 5.04 update 1 (build 49) Tool: ArmCC [5040049]
; commandline ArmCC [--list --split_sections --debug -c --asm --interleave -o.\obj\uartapi.o --asm_dir=.\list\ --list_dir=.\list\ --depend=.\obj\uartapi.d --cpu=Cortex-M0 --apcs=interwork -O0 -I.\BSP_lib\Inc\Driver -I.\CMSIS\CMOSupport -I.\CMSIS\NUC1xxSupport -I.\User\inc -I.\modbus\include -I.\modbus\MBport -I.\modbus\rtu -I"D:\Program Files\keil\ARM\RV31\INC" -I"D:\Program Files\keil\ARM\PACK\ARM\CMSIS\3.20.4\CMSIS\Include" -I"D:\Program Files\keil\ARM\Inc\Nuvoton\NUC1xx" --omf_browse=.\obj\uartapi.crf User\src\UartAPI.c]
                          THUMB

                          AREA ||i.DataExInit||, CODE, READONLY, ALIGN=2

                  DataExInit PROC
;;;57     
;;;58     u32bit DataExInit(void)
000000  b5fe              PUSH     {r1-r7,lr}
;;;59     {
;;;60         u8bit cnt;
;;;61         u8bit err_code = 0,CheckSum;
000002  2700              MOVS     r7,#0
;;;62         u32bit i,u32BaudRate;
;;;63     
;;;64         data_in_len = 2;
000004  2002              MOVS     r0,#2
000006  4983              LDR      r1,|L1.532|
000008  7008              STRB     r0,[r1,#0]
;;;65         data_out_len = 2;
00000a  4983              LDR      r1,|L1.536|
00000c  7008              STRB     r0,[r1,#0]
;;;66         S_RTS = 0;                                              //接口板允许接受
00000e  2000              MOVS     r0,#0
000010  4982              LDR      r1,|L1.540|
000012  6248              STR      r0,[r1,#0x24]
;;;67         REQ_IT = 1;                                             //接口板请求初始化数据
000014  2001              MOVS     r0,#1
000016  6208              STR      r0,[r1,#0x20]
;;;68     
;;;69         //等待接收初始化报文
;;;70         for(i=0; i<49; i++){
000018  2400              MOVS     r4,#0
00001a  e008              B        |L1.46|
                  |L1.28|
;;;71             err_code = Uart1Receive(&RxBuf[i]);
00001c  4980              LDR      r1,|L1.544|
00001e  1908              ADDS     r0,r1,r4
000020  f7fffffe          BL       Uart1Receive
000024  4607              MOV      r7,r0
;;;72             if(err_code) break;
000026  2f00              CMP      r7,#0
000028  d000              BEQ      |L1.44|
00002a  e002              B        |L1.50|
                  |L1.44|
00002c  1c64              ADDS     r4,r4,#1              ;70
                  |L1.46|
00002e  2c31              CMP      r4,#0x31              ;70
000030  d3f4              BCC      |L1.28|
                  |L1.50|
000032  bf00              NOP      
;;;73         }
;;;74         S_RTS = 1;                                              //接口板禁止接收数据
000034  2001              MOVS     r0,#1
000036  4979              LDR      r1,|L1.540|
000038  6248              STR      r0,[r1,#0x24]
;;;75     
;;;76         if(err_code == DATA_OK){
00003a  2f00              CMP      r7,#0
00003c  d11f              BNE      |L1.126|
;;;77             //计算累加和
;;;78             CheckSum=0;
00003e  2000              MOVS     r0,#0
000040  9001              STR      r0,[sp,#4]
;;;79             for (cnt=0;cnt<48;cnt++)    CheckSum=CheckSum+RxBuf[cnt];
000042  2600              MOVS     r6,#0
000044  e007              B        |L1.86|
                  |L1.70|
000046  4876              LDR      r0,|L1.544|
000048  5d81              LDRB     r1,[r0,r6]
00004a  9801              LDR      r0,[sp,#4]
00004c  1808              ADDS     r0,r1,r0
00004e  b2c0              UXTB     r0,r0
000050  9001              STR      r0,[sp,#4]
000052  1c70              ADDS     r0,r6,#1
000054  b2c6              UXTB     r6,r0
                  |L1.86|
000056  2e30              CMP      r6,#0x30
000058  dbf5              BLT      |L1.70|
;;;80     
;;;81             //计数交互数据报文的长度
;;;82     //        for(cnt = 0; cnt < RxBuf[3];cnt++){
;;;83     //            if((RxBuf[4+cnt] >= 0x10) && (RxBuf[4+cnt] < 0x20)){
;;;84     //                data_in_len = data_in_len + RxBuf[4+cnt] - 0x0F;
;;;85     //            }
;;;86     //            else if((RxBuf[4+cnt] >= 0x20) && (RxBuf[4+cnt] < 0x30)){
;;;87     //                data_out_len = data_out_len + RxBuf[4+cnt] - 0x1F;
;;;88     //            }
;;;89     //            else err_code = CONFIGDATA_Err;
;;;90     //        }
;;;91             data_in_len     = RxBuf[25];
00005a  4871              LDR      r0,|L1.544|
00005c  7e40              LDRB     r0,[r0,#0x19]  ; RxBuf
00005e  496d              LDR      r1,|L1.532|
000060  7008              STRB     r0,[r1,#0]
;;;92             data_out_len    = RxBuf[24];
000062  486f              LDR      r0,|L1.544|
000064  7e00              LDRB     r0,[r0,#0x18]  ; RxBuf
000066  496c              LDR      r1,|L1.536|
000068  7008              STRB     r0,[r1,#0]
;;;93             dil=data_in_len-1;                                  //data_in_len=50,dil=49
00006a  486a              LDR      r0,|L1.532|
00006c  7800              LDRB     r0,[r0,#0]  ; data_in_len
00006e  1e40              SUBS     r0,r0,#1
000070  496c              LDR      r1,|L1.548|
000072  7008              STRB     r0,[r1,#0]
;;;94             dol=data_out_len-1;                                 //data_out_len=50,dol==49
000074  4868              LDR      r0,|L1.536|
000076  7800              LDRB     r0,[r0,#0]  ; data_out_len
000078  1e40              SUBS     r0,r0,#1
00007a  496b              LDR      r1,|L1.552|
00007c  7008              STRB     r0,[r1,#0]
                  |L1.126|
;;;95         }
;;;96     
;;;97         //报文的正确性验证
;;;98         if(i != 49){                                            //报文长度错误
00007e  2c31              CMP      r4,#0x31
000080  d003              BEQ      |L1.138|
;;;99             TxBuf[1] = 6;
000082  2006              MOVS     r0,#6
000084  4969              LDR      r1,|L1.556|
000086  7048              STRB     r0,[r1,#1]
000088  e028              B        |L1.220|
                  |L1.138|
;;;100        }
;;;101        else if(err_code == PE_Err){                            //奇偶校验错误
00008a  2f02              CMP      r7,#2
00008c  d103              BNE      |L1.150|
;;;102            TxBuf[1] = 5;
00008e  2005              MOVS     r0,#5
000090  4966              LDR      r1,|L1.556|
000092  7048              STRB     r0,[r1,#1]
000094  e022              B        |L1.220|
                  |L1.150|
;;;103        }
;;;104        else if(CheckSum != RxBuf[48]){                         //校验和错误
000096  4862              LDR      r0,|L1.544|
000098  3020              ADDS     r0,r0,#0x20
00009a  7c01              LDRB     r1,[r0,#0x10]  ; RxBuf
00009c  9801              LDR      r0,[sp,#4]
00009e  4281              CMP      r1,r0
0000a0  d003              BEQ      |L1.170|
;;;105            TxBuf[1] = 4;
0000a2  2004              MOVS     r0,#4
0000a4  4961              LDR      r1,|L1.556|
0000a6  7048              STRB     r0,[r1,#1]
0000a8  e018              B        |L1.220|
                  |L1.170|
;;;106        }
;;;107        else if(RxBuf[0]>126){                                  //站号错误
0000aa  485d              LDR      r0,|L1.544|
0000ac  7800              LDRB     r0,[r0,#0]  ; RxBuf
0000ae  287e              CMP      r0,#0x7e
0000b0  dd03              BLE      |L1.186|
;;;108            TxBuf[1] = 3;
0000b2  2003              MOVS     r0,#3
0000b4  495d              LDR      r1,|L1.556|
0000b6  7048              STRB     r0,[r1,#1]
0000b8  e010              B        |L1.220|
                  |L1.186|
;;;109        }
;;;110        else if(RxBuf[3]>8){                                    //数据配置长度错误
0000ba  4859              LDR      r0,|L1.544|
0000bc  78c0              LDRB     r0,[r0,#3]  ; RxBuf
0000be  2808              CMP      r0,#8
0000c0  dd03              BLE      |L1.202|
;;;111            TxBuf[1] = 2;
0000c2  2002              MOVS     r0,#2
0000c4  4959              LDR      r1,|L1.556|
0000c6  7048              STRB     r0,[r1,#1]
0000c8  e008              B        |L1.220|
                  |L1.202|
;;;112        }
;;;113        else if(err_code == CONFIGDATA_Err){
0000ca  2f03              CMP      r7,#3
0000cc  d103              BNE      |L1.214|
;;;114            TxBuf[1] = 1;
0000ce  2001              MOVS     r0,#1
0000d0  4956              LDR      r1,|L1.556|
0000d2  7048              STRB     r0,[r1,#1]
0000d4  e002              B        |L1.220|
                  |L1.214|
;;;115        }
;;;116        else{
;;;117            TxBuf[1] = 0;
0000d6  2000              MOVS     r0,#0
0000d8  4954              LDR      r1,|L1.556|
0000da  7048              STRB     r0,[r1,#1]
                  |L1.220|
;;;118        }
;;;119    
;;;120        //初始化应答报文生成
;;;121        TxBuf[0] = GPC_2;                                       //计算设置的波特率代码
0000dc  484f              LDR      r0,|L1.540|
0000de  3080              ADDS     r0,r0,#0x80
0000e0  6880              LDR      r0,[r0,#8]
0000e2  4952              LDR      r1,|L1.556|
0000e4  7008              STRB     r0,[r1,#0]
;;;122        TxBuf[0] = (TxBuf[0]<<1) + GPC_1;
0000e6  4608              MOV      r0,r1
0000e8  7800              LDRB     r0,[r0,#0]  ; TxBuf
0000ea  0040              LSLS     r0,r0,#1
0000ec  494b              LDR      r1,|L1.540|
0000ee  3180              ADDS     r1,r1,#0x80
0000f0  6849              LDR      r1,[r1,#4]
0000f2  1840              ADDS     r0,r0,r1
0000f4  494d              LDR      r1,|L1.556|
0000f6  7008              STRB     r0,[r1,#0]
;;;123        TxBuf[0] = (TxBuf[0]<<1) + GPC_0;
0000f8  4608              MOV      r0,r1
0000fa  7800              LDRB     r0,[r0,#0]  ; TxBuf
0000fc  0040              LSLS     r0,r0,#1
0000fe  4947              LDR      r1,|L1.540|
000100  3180              ADDS     r1,r1,#0x80
000102  6809              LDR      r1,[r1,#0]
000104  1840              ADDS     r0,r0,r1
000106  4949              LDR      r1,|L1.556|
000108  7008              STRB     r0,[r1,#0]
;;;124        if(TxBuf[1]==0){                                        //生成正确应答报文
00010a  4608              MOV      r0,r1
00010c  7840              LDRB     r0,[r0,#1]  ; TxBuf
00010e  2800              CMP      r0,#0
000110  d14a              BNE      |L1.424|
;;;125            for(i=2;i<48;i++)   TxBuf[i] = 0xaa;
000112  2402              MOVS     r4,#2
000114  e003              B        |L1.286|
                  |L1.278|
000116  20aa              MOVS     r0,#0xaa
000118  4944              LDR      r1,|L1.556|
00011a  5508              STRB     r0,[r1,r4]
00011c  1c64              ADDS     r4,r4,#1
                  |L1.286|
00011e  2c30              CMP      r4,#0x30
000120  d3f9              BCC      |L1.278|
;;;126            switch(RxBuf[12]){
000122  483f              LDR      r0,|L1.544|
000124  7b00              LDRB     r0,[r0,#0xc]  ; RxBuf
000126  0003              MOVS     r3,r0
000128  f7fffffe          BL       __ARM_common_switch8
00012c  0a06090c          DCB      0x0a,0x06,0x09,0x0c
000130  0f121518          DCB      0x0f,0x12,0x15,0x18
000134  1b1e2022          DCB      0x1b,0x1e,0x20,0x22
;;;127                case 0:
;;;128                    u32BaudRate = 1200;
000138  254b              MOVS     r5,#0x4b
00013a  012d              LSLS     r5,r5,#4
;;;129                    break;
00013c  e01b              B        |L1.374|
;;;130                case 1:
;;;131                    u32BaudRate = 2400;
00013e  254b              MOVS     r5,#0x4b
000140  016d              LSLS     r5,r5,#5
;;;132                    break;
000142  e018              B        |L1.374|
;;;133                case 2:
;;;134                    u32BaudRate = 4800;
000144  254b              MOVS     r5,#0x4b
000146  01ad              LSLS     r5,r5,#6
;;;135                    break;
000148  e015              B        |L1.374|
;;;136                case 3:
;;;137                    u32BaudRate = 9600;
00014a  254b              MOVS     r5,#0x4b
00014c  01ed              LSLS     r5,r5,#7
;;;138                    break;
00014e  e012              B        |L1.374|
;;;139                case 4:
;;;140                    u32BaudRate = 19200;
000150  254b              MOVS     r5,#0x4b
000152  022d              LSLS     r5,r5,#8
;;;141                    break;
000154  e00f              B        |L1.374|
;;;142                case 5:
;;;143                    u32BaudRate = 38400;
000156  254b              MOVS     r5,#0x4b
000158  026d              LSLS     r5,r5,#9
;;;144                    break;
00015a  e00c              B        |L1.374|
;;;145                case 6:
;;;146                    u32BaudRate = 57600;
00015c  25e1              MOVS     r5,#0xe1
00015e  022d              LSLS     r5,r5,#8
;;;147                    break;
000160  e009              B        |L1.374|
;;;148                case 7:
;;;149                    u32BaudRate = 115200;
000162  25e1              MOVS     r5,#0xe1
000164  026d              LSLS     r5,r5,#9
;;;150                    break;
000166  e006              B        |L1.374|
;;;151                case 8:
;;;152                    u32BaudRate = 125000;
000168  4d31              LDR      r5,|L1.560|
;;;153                    break;
00016a  e004              B        |L1.374|
;;;154                case 9:
;;;155                    u32BaudRate = 187500;
00016c  4d31              LDR      r5,|L1.564|
;;;156                    break;
00016e  e002              B        |L1.374|
;;;157                default:
;;;158                    u32BaudRate = 9600;
000170  254b              MOVS     r5,#0x4b
000172  01ed              LSLS     r5,r5,#7
;;;159                    break;
000174  bf00              NOP      
                  |L1.374|
000176  bf00              NOP                            ;129
;;;160            }
;;;161            eMBInit(MB_RTU,RxBuf[0],1,u32BaudRate,(eMBParity)RxBuf[13]);    //初始化接口板
000178  4829              LDR      r0,|L1.544|
00017a  7b40              LDRB     r0,[r0,#0xd]  ; RxBuf
00017c  9000              STR      r0,[sp,#0]
00017e  4828              LDR      r0,|L1.544|
000180  7801              LDRB     r1,[r0,#0]  ; RxBuf
000182  462b              MOV      r3,r5
000184  2201              MOVS     r2,#1
000186  2000              MOVS     r0,#0
000188  f7fffffe          BL       eMBInit
;;;162            eMBSetSlaveID(0x01,0xff,"BHYW-DP,CODE:0-01-00",21);
00018c  2315              MOVS     r3,#0x15
00018e  a22a              ADR      r2,|L1.568|
000190  21ff              MOVS     r1,#0xff
000192  2001              MOVS     r0,#1
000194  f7fffffe          BL       eMBSetSlaveID
;;;163            eMBEnable();
000198  f7fffffe          BL       eMBEnable
;;;164            RDY = 1;                                            //接收初始化数据完毕指示
00019c  2001              MOVS     r0,#1
00019e  491f              LDR      r1,|L1.540|
0001a0  62c8              STR      r0,[r1,#0x2c]
;;;165            REQ_IT = 0;                                         //进入数据交互状态
0001a2  2000              MOVS     r0,#0
0001a4  6208              STR      r0,[r1,#0x20]
0001a6  e007              B        |L1.440|
                  |L1.424|
;;;166        }
;;;167        else{                                                   //生成错误应答报文
;;;168            for(i=2;i<48;i++)   TxBuf[i] = 0x55;
0001a8  2402              MOVS     r4,#2
0001aa  e003              B        |L1.436|
                  |L1.428|
0001ac  2055              MOVS     r0,#0x55
0001ae  491f              LDR      r1,|L1.556|
0001b0  5508              STRB     r0,[r1,r4]
0001b2  1c64              ADDS     r4,r4,#1
                  |L1.436|
0001b4  2c30              CMP      r4,#0x30
0001b6  d3f9              BCC      |L1.428|
                  |L1.440|
;;;169        }
;;;170        TxBuf[48]=0;                                            //计算应答报文累加和.
0001b8  2100              MOVS     r1,#0
0001ba  481c              LDR      r0,|L1.556|
0001bc  3020              ADDS     r0,r0,#0x20
0001be  7401              STRB     r1,[r0,#0x10]
;;;171        for(i=0;i<48;i++)   TxBuf[48]=TxBuf[48]+TxBuf[i];
0001c0  2400              MOVS     r4,#0
0001c2  e00a              B        |L1.474|
                  |L1.452|
0001c4  4819              LDR      r0,|L1.556|
0001c6  3020              ADDS     r0,r0,#0x20
0001c8  7c00              LDRB     r0,[r0,#0x10]  ; TxBuf
0001ca  4918              LDR      r1,|L1.556|
0001cc  5d09              LDRB     r1,[r1,r4]
0001ce  1840              ADDS     r0,r0,r1
0001d0  b2c1              UXTB     r1,r0
0001d2  4816              LDR      r0,|L1.556|
0001d4  3020              ADDS     r0,r0,#0x20
0001d6  7401              STRB     r1,[r0,#0x10]
0001d8  1c64              ADDS     r4,r4,#1
                  |L1.474|
0001da  2c30              CMP      r4,#0x30
0001dc  d3f2              BCC      |L1.452|
;;;172    
;;;173        //发送应答报文
;;;174        for(i=0; i<49; i++){
0001de  2400              MOVS     r4,#0
0001e0  e004              B        |L1.492|
                  |L1.482|
;;;175            Uart1Send(TxBuf[i]);
0001e2  4912              LDR      r1,|L1.556|
0001e4  5d08              LDRB     r0,[r1,r4]
0001e6  f7fffffe          BL       Uart1Send
0001ea  1c64              ADDS     r4,r4,#1              ;174
                  |L1.492|
0001ec  2c31              CMP      r4,#0x31              ;174
0001ee  d3f8              BCC      |L1.482|
;;;176        }
;;;177        DelayUs(200);
0001f0  20c8              MOVS     r0,#0xc8
0001f2  f7fffffe          BL       DrvSYS_Delay
;;;178        //清空发送区域报文
;;;179        for(i=0; i<49; i++){
0001f6  2400              MOVS     r4,#0
0001f8  e003              B        |L1.514|
                  |L1.506|
;;;180            TxBuf[i] = 0;
0001fa  2000              MOVS     r0,#0
0001fc  490b              LDR      r1,|L1.556|
0001fe  5508              STRB     r0,[r1,r4]
000200  1c64              ADDS     r4,r4,#1              ;179
                  |L1.514|
000202  2c31              CMP      r4,#0x31              ;179
000204  d3f9              BCC      |L1.506|
;;;181        }
;;;182        //返回初始化是否完成的信息
;;;183        if(TxBuf[1]==0) return E_SUCCESS;
000206  4809              LDR      r0,|L1.556|
000208  7840              LDRB     r0,[r0,#1]  ; TxBuf
00020a  2800              CMP      r0,#0
00020c  d100              BNE      |L1.528|
                  |L1.526|
;;;184        else    return 1;
;;;185    }
00020e  bdfe              POP      {r1-r7,pc}
                  |L1.528|
000210  2001              MOVS     r0,#1                 ;184
000212  e7fc              B        |L1.526|
;;;186    
                          ENDP

                  |L1.532|
                          DCD      data_in_len
                  |L1.536|
                          DCD      data_out_len
                  |L1.540|
                          DCD      0x50004200
                  |L1.544|
                          DCD      RxBuf
                  |L1.548|
                          DCD      ||dil||
                  |L1.552|
                          DCD      ||dol||
                  |L1.556|
                          DCD      TxBuf
                  |L1.560|
                          DCD      0x0001e848
                  |L1.564|
                          DCD      0x0002dc6c
                  |L1.568|
000238  42485957          DCB      "BHYW-DP,CODE:0-01-00",0
00023c  2d44502c
000240  434f4445
000244  3a302d30
000248  312d3030
00024c  00      
00024d  00                DCB      0
00024e  00                DCB      0
00024f  00                DCB      0

                          AREA ||i.DataExRoutine||, CODE, READONLY, ALIGN=2

                  DataExRoutine PROC
;;;186    
;;;187    void DataExRoutine(void)
000000  b5f8              PUSH     {r3-r7,lr}
;;;188    {
;;;189        u8bit cnt;
;;;190        u8bit err_code = 0,CheckSum;
000002  2600              MOVS     r6,#0
;;;191        u32bit i;
;;;192    
;;;193        S_RTS = 0;                                              //接口板进入数据交换
000004  2000              MOVS     r0,#0
000006  4948              LDR      r1,|L2.296|
000008  6248              STR      r0,[r1,#0x24]
;;;194        REQ_IT = 0;                                             //接口板请求初始化数据
00000a  6208              STR      r0,[r1,#0x20]
;;;195    
;;;196        //等待接收初始化报文
;;;197        for(i=0; i<data_in_len; i++){
00000c  2500              MOVS     r5,#0
00000e  e008              B        |L2.34|
                  |L2.16|
;;;198            err_code = Uart1Receive(&RxBuf[i]);
000010  4946              LDR      r1,|L2.300|
000012  1948              ADDS     r0,r1,r5
000014  f7fffffe          BL       Uart1Receive
000018  4606              MOV      r6,r0
;;;199            if(err_code)
00001a  2e00              CMP      r6,#0
00001c  d000              BEQ      |L2.32|
;;;200                break;
00001e  e004              B        |L2.42|
                  |L2.32|
000020  1c6d              ADDS     r5,r5,#1              ;197
                  |L2.34|
000022  4843              LDR      r0,|L2.304|
000024  7800              LDRB     r0,[r0,#0]            ;197  ; data_in_len
000026  4285              CMP      r5,r0                 ;197
000028  d3f2              BCC      |L2.16|
                  |L2.42|
00002a  bf00              NOP      
;;;201        }
;;;202        S_RTS = 1;                                              //接口板禁止接收数据
00002c  2001              MOVS     r0,#1
00002e  493e              LDR      r1,|L2.296|
000030  6248              STR      r0,[r1,#0x24]
;;;203    
;;;204        //数据交换报文查错检验
;;;205        if(err_code == DATA_OK){
000032  2e00              CMP      r6,#0
000034  d10f              BNE      |L2.86|
;;;206            //计算累加和
;;;207            CheckSum=0;
000036  2700              MOVS     r7,#0
;;;208            for (cnt=0;cnt<dil;cnt++)   CheckSum=CheckSum+RxBuf[cnt];
000038  2400              MOVS     r4,#0
00003a  e005              B        |L2.72|
                  |L2.60|
00003c  483b              LDR      r0,|L2.300|
00003e  5d00              LDRB     r0,[r0,r4]
000040  19c0              ADDS     r0,r0,r7
000042  b2c7              UXTB     r7,r0
000044  1c60              ADDS     r0,r4,#1
000046  b2c4              UXTB     r4,r0
                  |L2.72|
000048  483a              LDR      r0,|L2.308|
00004a  7800              LDRB     r0,[r0,#0]  ; dil
00004c  4284              CMP      r4,r0
00004e  dbf5              BLT      |L2.60|
;;;209            TxBuf[0] = 0;
000050  2000              MOVS     r0,#0
000052  4939              LDR      r1,|L2.312|
000054  7008              STRB     r0,[r1,#0]
                  |L2.86|
;;;210        }
;;;211        if(err_code == PE_Err){
000056  2e02              CMP      r6,#2
000058  d103              BNE      |L2.98|
;;;212            TxBuf[0] = 1;
00005a  2001              MOVS     r0,#1
00005c  4936              LDR      r1,|L2.312|
00005e  7008              STRB     r0,[r1,#0]
000060  e008              B        |L2.116|
                  |L2.98|
;;;213        }
;;;214        else if(CheckSum != RxBuf[dil]){
000062  4832              LDR      r0,|L2.300|
000064  4933              LDR      r1,|L2.308|
000066  7809              LDRB     r1,[r1,#0]  ; dil
000068  5c40              LDRB     r0,[r0,r1]
00006a  42b8              CMP      r0,r7
00006c  d002              BEQ      |L2.116|
;;;215            TxBuf[0] = 2;
00006e  2002              MOVS     r0,#2
000070  4931              LDR      r1,|L2.312|
000072  7008              STRB     r0,[r1,#0]
                  |L2.116|
;;;216        }
;;;217        PBF = 1;
000074  2001              MOVS     r0,#1
000076  492c              LDR      r1,|L2.296|
000078  6288              STR      r0,[r1,#0x28]
;;;218        //更新modbus寄存器
;;;219        TxBuf[35] &= ~RxBuf[48];                                //操作标志寄存器刷新
00007a  482f              LDR      r0,|L2.312|
00007c  3020              ADDS     r0,r0,#0x20
00007e  78c0              LDRB     r0,[r0,#3]  ; TxBuf
000080  492a              LDR      r1,|L2.300|
000082  3120              ADDS     r1,r1,#0x20
000084  7c09              LDRB     r1,[r1,#0x10]  ; RxBuf
000086  4388              BICS     r0,r0,r1
000088  492b              LDR      r1,|L2.312|
00008a  3120              ADDS     r1,r1,#0x20
00008c  70c8              STRB     r0,[r1,#3]
;;;220        TxBuf[36] &= ~RxBuf[49];                                //操作标志寄存器刷新
00008e  4608              MOV      r0,r1
000090  7900              LDRB     r0,[r0,#4]  ; TxBuf
000092  4926              LDR      r1,|L2.300|
000094  3120              ADDS     r1,r1,#0x20
000096  7c49              LDRB     r1,[r1,#0x11]  ; RxBuf
000098  4388              BICS     r0,r0,r1
00009a  4927              LDR      r1,|L2.312|
00009c  3120              ADDS     r1,r1,#0x20
00009e  7108              STRB     r0,[r1,#4]
;;;221        if(RxBuf[47] & BIT3)    TxBuf[34] &= ~BIT3;
0000a0  4822              LDR      r0,|L2.300|
0000a2  3020              ADDS     r0,r0,#0x20
0000a4  7bc0              LDRB     r0,[r0,#0xf]  ; RxBuf
0000a6  2108              MOVS     r1,#8
0000a8  4008              ANDS     r0,r0,r1
0000aa  2800              CMP      r0,#0
0000ac  d006              BEQ      |L2.188|
0000ae  4822              LDR      r0,|L2.312|
0000b0  3020              ADDS     r0,r0,#0x20
0000b2  7880              LDRB     r0,[r0,#2]  ; TxBuf
0000b4  4388              BICS     r0,r0,r1
0000b6  4920              LDR      r1,|L2.312|
0000b8  3120              ADDS     r1,r1,#0x20
0000ba  7088              STRB     r0,[r1,#2]
                  |L2.188|
;;;222        if(RxBuf[48] & BIT7)    TxBuf[35] &= ~BIT7;
0000bc  481b              LDR      r0,|L2.300|
0000be  3020              ADDS     r0,r0,#0x20
0000c0  7c00              LDRB     r0,[r0,#0x10]  ; RxBuf
0000c2  2180              MOVS     r1,#0x80
0000c4  4008              ANDS     r0,r0,r1
0000c6  2800              CMP      r0,#0
0000c8  d006              BEQ      |L2.216|
0000ca  481b              LDR      r0,|L2.312|
0000cc  3020              ADDS     r0,r0,#0x20
0000ce  78c0              LDRB     r0,[r0,#3]  ; TxBuf
0000d0  4388              BICS     r0,r0,r1
0000d2  4919              LDR      r1,|L2.312|
0000d4  3120              ADDS     r1,r1,#0x20
0000d6  70c8              STRB     r0,[r1,#3]
                  |L2.216|
;;;223        //TxBuf[34] &= ~(RxBuf[47] & (BIT3 | BIT4));
;;;224        if(TxBuf[0] == 0){
;;;225            //ModbusRegRefrash();
;;;226        }
;;;227    
;;;228        //计算校验和
;;;229        TxBuf[dol]=0;
0000d8  2000              MOVS     r0,#0
0000da  4917              LDR      r1,|L2.312|
0000dc  4a17              LDR      r2,|L2.316|
0000de  7812              LDRB     r2,[r2,#0]  ; dol
0000e0  5488              STRB     r0,[r1,r2]
;;;230        for (cnt=0;cnt<dol;cnt++)   TxBuf[dol] += TxBuf[cnt];
0000e2  2400              MOVS     r4,#0
0000e4  e00c              B        |L2.256|
                  |L2.230|
0000e6  4814              LDR      r0,|L2.312|
0000e8  4914              LDR      r1,|L2.316|
0000ea  7809              LDRB     r1,[r1,#0]  ; dol
0000ec  5c40              LDRB     r0,[r0,r1]
0000ee  4912              LDR      r1,|L2.312|
0000f0  5d09              LDRB     r1,[r1,r4]
0000f2  1840              ADDS     r0,r0,r1
0000f4  4910              LDR      r1,|L2.312|
0000f6  4a11              LDR      r2,|L2.316|
0000f8  7812              LDRB     r2,[r2,#0]  ; dol
0000fa  5488              STRB     r0,[r1,r2]
0000fc  1c60              ADDS     r0,r4,#1
0000fe  b2c4              UXTB     r4,r0
                  |L2.256|
000100  480e              LDR      r0,|L2.316|
000102  7800              LDRB     r0,[r0,#0]  ; dol
000104  4284              CMP      r4,r0
000106  dbee              BLT      |L2.230|
;;;231        //发送应答数据报文.
;;;232        for(i=0; i<data_out_len; i++){
000108  2500              MOVS     r5,#0
00010a  e004              B        |L2.278|
                  |L2.268|
;;;233            Uart1Send(TxBuf[i]);
00010c  490a              LDR      r1,|L2.312|
00010e  5d48              LDRB     r0,[r1,r5]
000110  f7fffffe          BL       Uart1Send
000114  1c6d              ADDS     r5,r5,#1              ;232
                  |L2.278|
000116  480a              LDR      r0,|L2.320|
000118  7800              LDRB     r0,[r0,#0]            ;232  ; data_out_len
00011a  4285              CMP      r5,r0                 ;232
00011c  d3f6              BCC      |L2.268|
;;;234        }
;;;235        DelayUs(500);
00011e  20ff              MOVS     r0,#0xff
000120  30f5              ADDS     r0,r0,#0xf5
000122  f7fffffe          BL       DrvSYS_Delay
;;;236    }
000126  bdf8              POP      {r3-r7,pc}
;;;237    
                          ENDP

                  |L2.296|
                          DCD      0x50004200
                  |L2.300|
                          DCD      RxBuf
                  |L2.304|
                          DCD      data_in_len
                  |L2.308|
                          DCD      ||dil||
                  |L2.312|
                          DCD      TxBuf
                  |L2.316|
                          DCD      ||dol||
                  |L2.320|
                          DCD      data_out_len

                          AREA ||i.MBCoilsRead||, CODE, READONLY, ALIGN=2

                  MBCoilsRead PROC
;;;579    //线圈读更新
;;;580    void MBCoilsRead(void)
000000  4806              LDR      r0,|L3.28|
;;;581    {
;;;582        usRegCoilsBuf[0] = (RxBuf[47] & 0x0f) | ((RxBuf[48]>>3) & BIT4);
000002  7bc0              LDRB     r0,[r0,#0xf]  ; RxBuf
000004  0700              LSLS     r0,r0,#28
000006  0f00              LSRS     r0,r0,#28
000008  4904              LDR      r1,|L3.28|
00000a  7c09              LDRB     r1,[r1,#0x10]  ; RxBuf
00000c  10c9              ASRS     r1,r1,#3
00000e  2210              MOVS     r2,#0x10
000010  4011              ANDS     r1,r1,r2
000012  4308              ORRS     r0,r0,r1
000014  4902              LDR      r1,|L3.32|
000016  7008              STRB     r0,[r1,#0]
;;;583    }
000018  4770              BX       lr
;;;584    //线圈写更新
                          ENDP

00001a  0000              DCW      0x0000
                  |L3.28|
                          DCD      RxBuf+0x20
                  |L3.32|
                          DCD      usRegCoilsBuf

                          AREA ||i.MBCoilsWrite||, CODE, READONLY, ALIGN=2

                  MBCoilsWrite PROC
;;;584    //线圈写更新
;;;585    void MBCoilsWrite(void)
000000  4807              LDR      r0,|L4.32|
;;;586    {
;;;587        TxBuf[34] = usRegCoilsBuf[0] & 0X0F;
000002  7800              LDRB     r0,[r0,#0]  ; usRegCoilsBuf
000004  0701              LSLS     r1,r0,#28
000006  0f09              LSRS     r1,r1,#28
000008  4806              LDR      r0,|L4.36|
00000a  7081              STRB     r1,[r0,#2]
;;;588        TxBuf[35] |= ((usRegCoilsBuf[0] & BIT4)<<3);
00000c  78c0              LDRB     r0,[r0,#3]  ; TxBuf
00000e  4904              LDR      r1,|L4.32|
000010  7809              LDRB     r1,[r1,#0]  ; usRegCoilsBuf
000012  2210              MOVS     r2,#0x10
000014  4011              ANDS     r1,r1,r2
000016  00c9              LSLS     r1,r1,#3
000018  4308              ORRS     r0,r0,r1
00001a  4902              LDR      r1,|L4.36|
00001c  70c8              STRB     r0,[r1,#3]
;;;589    }
00001e  4770              BX       lr
;;;590    //离散量输入读更新
                          ENDP

                  |L4.32|
                          DCD      usRegCoilsBuf
                  |L4.36|
                          DCD      TxBuf+0x20

                          AREA ||i.MBDiscreteRead||, CODE, READONLY, ALIGN=2

                  MBDiscreteRead PROC
;;;590    //离散量输入读更新
;;;591    void MBDiscreteRead(void)
000000  4809              LDR      r0,|L5.40|
;;;592    {
;;;593    	usRegDiscreteBuf[0] = RxBuf[43];
000002  7ac0              LDRB     r0,[r0,#0xb]  ; RxBuf
000004  4909              LDR      r1,|L5.44|
000006  7008              STRB     r0,[r1,#0]
;;;594    	usRegDiscreteBuf[1] = RxBuf[42];
000008  4807              LDR      r0,|L5.40|
00000a  7a80              LDRB     r0,[r0,#0xa]  ; RxBuf
00000c  7048              STRB     r0,[r1,#1]
;;;595    	usRegDiscreteBuf[2] = RxBuf[45];
00000e  4806              LDR      r0,|L5.40|
000010  7b40              LDRB     r0,[r0,#0xd]  ; RxBuf
000012  7088              STRB     r0,[r1,#2]
;;;596    	usRegDiscreteBuf[3] = RxBuf[44];
000014  4804              LDR      r0,|L5.40|
000016  7b00              LDRB     r0,[r0,#0xc]  ; RxBuf
000018  70c8              STRB     r0,[r1,#3]
;;;597    	usRegDiscreteBuf[4] = RxBuf[46];
00001a  4803              LDR      r0,|L5.40|
00001c  7b80              LDRB     r0,[r0,#0xe]  ; RxBuf
00001e  7108              STRB     r0,[r1,#4]
;;;598    	usRegDiscreteBuf[5] = 0;
000020  2000              MOVS     r0,#0
000022  7148              STRB     r0,[r1,#5]
;;;599    }
000024  4770              BX       lr
;;;600    
                          ENDP

000026  0000              DCW      0x0000
                  |L5.40|
                          DCD      RxBuf+0x20
                  |L5.44|
                          DCD      usRegDiscreteBuf

                          AREA ||i.MBHoldingRegRead||, CODE, READONLY, ALIGN=2

                  MBHoldingRegRead PROC
;;;480    //保持寄存器读更新
;;;481    void MBHoldingRegRead(void)
000000  4868              LDR      r0,|L6.420|
;;;482    {
;;;483        *((u32bit *)(usRegHoldingBuf + 0))  = (RxBuf[9]<<24) + (RxBuf[10]<<16)
000002  7a40              LDRB     r0,[r0,#9]  ; RxBuf
000004  0600              LSLS     r0,r0,#24
000006  4967              LDR      r1,|L6.420|
000008  7a89              LDRB     r1,[r1,#0xa]  ; RxBuf
00000a  0409              LSLS     r1,r1,#16
00000c  1840              ADDS     r0,r0,r1
00000e  4965              LDR      r1,|L6.420|
000010  7ac9              LDRB     r1,[r1,#0xb]  ; RxBuf
000012  0209              LSLS     r1,r1,#8
000014  1840              ADDS     r0,r0,r1
000016  4963              LDR      r1,|L6.420|
000018  7b09              LDRB     r1,[r1,#0xc]  ; RxBuf
00001a  1840              ADDS     r0,r0,r1
00001c  4962              LDR      r1,|L6.424|
00001e  6008              STR      r0,[r1,#0]  ; usRegHoldingBuf
;;;484                                            + (RxBuf[11]<<8) + RxBuf[12];           //传感器量程
;;;485        *((u32bit *)(usRegHoldingBuf + 2))  = (RxBuf[13]<<24) + (RxBuf[14]<<16)
000020  4860              LDR      r0,|L6.420|
000022  7b40              LDRB     r0,[r0,#0xd]  ; RxBuf
000024  0600              LSLS     r0,r0,#24
000026  495f              LDR      r1,|L6.420|
000028  7b89              LDRB     r1,[r1,#0xe]  ; RxBuf
00002a  0409              LSLS     r1,r1,#16
00002c  1840              ADDS     r0,r0,r1
00002e  495d              LDR      r1,|L6.420|
000030  7bc9              LDRB     r1,[r1,#0xf]  ; RxBuf
000032  0209              LSLS     r1,r1,#8
000034  1840              ADDS     r0,r0,r1
000036  495b              LDR      r1,|L6.420|
000038  7c09              LDRB     r1,[r1,#0x10]  ; RxBuf
00003a  1840              ADDS     r0,r0,r1
00003c  495a              LDR      r1,|L6.424|
00003e  6048              STR      r0,[r1,#4]  ; usRegHoldingBuf
;;;486                                            + (RxBuf[15]<<8) + RxBuf[16];           //砝码输出值(AD得到)
;;;487        *((u32bit *)(usRegHoldingBuf + 4))  = (RxBuf[17]<<24) + (RxBuf[18]<<16)
000040  4858              LDR      r0,|L6.420|
000042  7c40              LDRB     r0,[r0,#0x11]  ; RxBuf
000044  0600              LSLS     r0,r0,#24
000046  4957              LDR      r1,|L6.420|
000048  7c89              LDRB     r1,[r1,#0x12]  ; RxBuf
00004a  0409              LSLS     r1,r1,#16
00004c  1840              ADDS     r0,r0,r1
00004e  4955              LDR      r1,|L6.420|
000050  7cc9              LDRB     r1,[r1,#0x13]  ; RxBuf
000052  0209              LSLS     r1,r1,#8
000054  1840              ADDS     r0,r0,r1
000056  4953              LDR      r1,|L6.420|
000058  7d09              LDRB     r1,[r1,#0x14]  ; RxBuf
00005a  1840              ADDS     r0,r0,r1
00005c  4952              LDR      r1,|L6.424|
00005e  6088              STR      r0,[r1,#8]  ; usRegHoldingBuf
;;;488                                            + (RxBuf[19]<<8) + RxBuf[20];           //砝码值
;;;489        *((u32bit *)(usRegHoldingBuf + 6))  = (RxBuf[21]<<24) + (RxBuf[22]<<16)
000060  4850              LDR      r0,|L6.420|
000062  7d40              LDRB     r0,[r0,#0x15]  ; RxBuf
000064  0600              LSLS     r0,r0,#24
000066  494f              LDR      r1,|L6.420|
000068  7d89              LDRB     r1,[r1,#0x16]  ; RxBuf
00006a  0409              LSLS     r1,r1,#16
00006c  1840              ADDS     r0,r0,r1
00006e  494d              LDR      r1,|L6.420|
000070  7dc9              LDRB     r1,[r1,#0x17]  ; RxBuf
000072  0209              LSLS     r1,r1,#8
000074  1840              ADDS     r0,r0,r1
000076  494b              LDR      r1,|L6.420|
000078  7e09              LDRB     r1,[r1,#0x18]  ; RxBuf
00007a  1840              ADDS     r0,r0,r1
00007c  494a              LDR      r1,|L6.424|
00007e  60c8              STR      r0,[r1,#0xc]  ; usRegHoldingBuf
;;;490                                            + (RxBuf[23]<<8) + RxBuf[24];           //皮重
;;;491        *((u32bit *)(usRegHoldingBuf + 8))  = (RxBuf[25]<<24) + (RxBuf[26]<<16)
000080  4848              LDR      r0,|L6.420|
000082  7e40              LDRB     r0,[r0,#0x19]  ; RxBuf
000084  0600              LSLS     r0,r0,#24
000086  4947              LDR      r1,|L6.420|
000088  7e89              LDRB     r1,[r1,#0x1a]  ; RxBuf
00008a  0409              LSLS     r1,r1,#16
00008c  1840              ADDS     r0,r0,r1
00008e  4945              LDR      r1,|L6.420|
000090  7ec9              LDRB     r1,[r1,#0x1b]  ; RxBuf
000092  0209              LSLS     r1,r1,#8
000094  1840              ADDS     r0,r0,r1
000096  4943              LDR      r1,|L6.420|
000098  7f09              LDRB     r1,[r1,#0x1c]  ; RxBuf
00009a  1840              ADDS     r0,r0,r1
00009c  4942              LDR      r1,|L6.424|
00009e  6108              STR      r0,[r1,#0x10]  ; usRegHoldingBuf
;;;492                                            + (RxBuf[27]<<8) + RxBuf[28];           //掉包计数器
;;;493        usRegHoldingBuf[10]                 = (RxBuf[29]<<8) + RxBuf[30];           //掉包设定值
0000a0  4840              LDR      r0,|L6.420|
0000a2  7f40              LDRB     r0,[r0,#0x1d]  ; RxBuf
0000a4  0200              LSLS     r0,r0,#8
0000a6  493f              LDR      r1,|L6.420|
0000a8  7f89              LDRB     r1,[r1,#0x1e]  ; RxBuf
0000aa  1840              ADDS     r0,r0,r1
0000ac  493e              LDR      r1,|L6.424|
0000ae  8288              STRH     r0,[r1,#0x14]
;;;494        usRegHoldingBuf[11]                 = (RxBuf[31]<<8) + RxBuf[32];           //粗细流切换值
0000b0  483c              LDR      r0,|L6.420|
0000b2  7fc0              LDRB     r0,[r0,#0x1f]  ; RxBuf
0000b4  0201              LSLS     r1,r0,#8
0000b6  483b              LDR      r0,|L6.420|
0000b8  3020              ADDS     r0,r0,#0x20
0000ba  7800              LDRB     r0,[r0,#0]  ; RxBuf
0000bc  1808              ADDS     r0,r1,r0
0000be  493a              LDR      r1,|L6.424|
0000c0  82c8              STRH     r0,[r1,#0x16]
;;;495        usRegHoldingBuf[12]                 = (RxBuf[33]<<8) + RxBuf[34];           //落差值
0000c2  4838              LDR      r0,|L6.420|
0000c4  3020              ADDS     r0,r0,#0x20
0000c6  7840              LDRB     r0,[r0,#1]  ; RxBuf
0000c8  0201              LSLS     r1,r0,#8
0000ca  4836              LDR      r0,|L6.420|
0000cc  3020              ADDS     r0,r0,#0x20
0000ce  7880              LDRB     r0,[r0,#2]  ; RxBuf
0000d0  1808              ADDS     r0,r1,r0
0000d2  4935              LDR      r1,|L6.424|
0000d4  8308              STRH     r0,[r1,#0x18]
;;;496        usRegHoldingBuf[13]                 = (RxBuf[35]<<8) + RxBuf[36];           //净差值
0000d6  4833              LDR      r0,|L6.420|
0000d8  3020              ADDS     r0,r0,#0x20
0000da  78c0              LDRB     r0,[r0,#3]  ; RxBuf
0000dc  0201              LSLS     r1,r0,#8
0000de  4831              LDR      r0,|L6.420|
0000e0  3020              ADDS     r0,r0,#0x20
0000e2  7900              LDRB     r0,[r0,#4]  ; RxBuf
0000e4  1808              ADDS     r0,r1,r0
0000e6  4930              LDR      r1,|L6.424|
0000e8  8348              STRH     r0,[r1,#0x1a]
;;;497        usRegHoldingBuf[14]                 = (RxBuf[37]<<8) + RxBuf[38];           //袋重修正值
0000ea  482e              LDR      r0,|L6.420|
0000ec  3020              ADDS     r0,r0,#0x20
0000ee  7940              LDRB     r0,[r0,#5]  ; RxBuf
0000f0  0201              LSLS     r1,r0,#8
0000f2  482c              LDR      r0,|L6.420|
0000f4  3020              ADDS     r0,r0,#0x20
0000f6  7980              LDRB     r0,[r0,#6]  ; RxBuf
0000f8  1808              ADDS     r0,r1,r0
0000fa  492b              LDR      r1,|L6.424|
0000fc  8388              STRH     r0,[r1,#0x1c]
;;;498        usRegHoldingBuf[15]                 = RxBuf[39];                            //滤波系数
0000fe  4829              LDR      r0,|L6.420|
000100  3020              ADDS     r0,r0,#0x20
000102  79c0              LDRB     r0,[r0,#7]  ; RxBuf
000104  83c8              STRH     r0,[r1,#0x1e]
;;;499        usRegHoldingBuf[16]                 = RxBuf[40];                            //跟踪袋数
000106  4827              LDR      r0,|L6.420|
000108  3020              ADDS     r0,r0,#0x20
00010a  7a00              LDRB     r0,[r0,#8]  ; RxBuf
00010c  8408              STRH     r0,[r1,#0x20]
;;;500        usRegHoldingBuf[17]                 = RxBuf[41];                            //抵达时间
00010e  4825              LDR      r0,|L6.420|
000110  3020              ADDS     r0,r0,#0x20
000112  7a40              LDRB     r0,[r0,#9]  ; RxBuf
000114  8448              STRH     r0,[r1,#0x22]
;;;501        if(RxBuf[47] & BIT4)    usRegHoldingBuf[18] = 1;                            //掉包计数器开关
000116  4823              LDR      r0,|L6.420|
000118  3020              ADDS     r0,r0,#0x20
00011a  7bc0              LDRB     r0,[r0,#0xf]  ; RxBuf
00011c  2110              MOVS     r1,#0x10
00011e  4008              ANDS     r0,r0,r1
000120  2800              CMP      r0,#0
000122  d003              BEQ      |L6.300|
000124  2001              MOVS     r0,#1
000126  4920              LDR      r1,|L6.424|
000128  8488              STRH     r0,[r1,#0x24]
00012a  e002              B        |L6.306|
                  |L6.300|
;;;502        else                    usRegHoldingBuf[18] = 0;
00012c  2000              MOVS     r0,#0
00012e  491e              LDR      r1,|L6.424|
000130  8488              STRH     r0,[r1,#0x24]
                  |L6.306|
;;;503        if(RxBuf[47] & BIT5)    usRegHoldingBuf[19] = 1;                            //粗细流切换开关
000132  481c              LDR      r0,|L6.420|
000134  3020              ADDS     r0,r0,#0x20
000136  7bc0              LDRB     r0,[r0,#0xf]  ; RxBuf
000138  2120              MOVS     r1,#0x20
00013a  4008              ANDS     r0,r0,r1
00013c  2800              CMP      r0,#0
00013e  d003              BEQ      |L6.328|
000140  2001              MOVS     r0,#1
000142  4919              LDR      r1,|L6.424|
000144  84c8              STRH     r0,[r1,#0x26]
000146  e002              B        |L6.334|
                  |L6.328|
;;;504        else                    usRegHoldingBuf[19] = 0;
000148  2000              MOVS     r0,#0
00014a  4917              LDR      r1,|L6.424|
00014c  84c8              STRH     r0,[r1,#0x26]
                  |L6.334|
;;;505        if(RxBuf[47] & BIT6)    usRegHoldingBuf[20] = 1;                            //开环追踪开关
00014e  4815              LDR      r0,|L6.420|
000150  3020              ADDS     r0,r0,#0x20
000152  7bc0              LDRB     r0,[r0,#0xf]  ; RxBuf
000154  2140              MOVS     r1,#0x40
000156  4008              ANDS     r0,r0,r1
000158  2800              CMP      r0,#0
00015a  d003              BEQ      |L6.356|
00015c  2001              MOVS     r0,#1
00015e  4912              LDR      r1,|L6.424|
000160  8508              STRH     r0,[r1,#0x28]
000162  e002              B        |L6.362|
                  |L6.356|
;;;506        else                    usRegHoldingBuf[20] = 0;
000164  2000              MOVS     r0,#0
000166  4910              LDR      r1,|L6.424|
000168  8508              STRH     r0,[r1,#0x28]
                  |L6.362|
;;;507        if(RxBuf[47] & BIT7)    usRegHoldingBuf[21] = 1;                            //闭环校正开关
00016a  480e              LDR      r0,|L6.420|
00016c  3020              ADDS     r0,r0,#0x20
00016e  7bc0              LDRB     r0,[r0,#0xf]  ; RxBuf
000170  2180              MOVS     r1,#0x80
000172  4008              ANDS     r0,r0,r1
000174  2800              CMP      r0,#0
000176  d003              BEQ      |L6.384|
000178  2001              MOVS     r0,#1
00017a  490b              LDR      r1,|L6.424|
00017c  8548              STRH     r0,[r1,#0x2a]
00017e  e002              B        |L6.390|
                  |L6.384|
;;;508        else                    usRegHoldingBuf[21] = 0;
000180  2000              MOVS     r0,#0
000182  4909              LDR      r1,|L6.424|
000184  8548              STRH     r0,[r1,#0x2a]
                  |L6.390|
;;;509        usRegHoldingBuf[22]                 = RxBuf[50];
000186  4807              LDR      r0,|L6.420|
000188  3020              ADDS     r0,r0,#0x20
00018a  7c80              LDRB     r0,[r0,#0x12]  ; RxBuf
00018c  4906              LDR      r1,|L6.424|
00018e  8588              STRH     r0,[r1,#0x2c]
;;;510        usRegHoldingBuf[23]                 = RxBuf[51];
000190  4804              LDR      r0,|L6.420|
000192  3020              ADDS     r0,r0,#0x20
000194  7cc0              LDRB     r0,[r0,#0x13]  ; RxBuf
000196  85c8              STRH     r0,[r1,#0x2e]
;;;511        usRegHoldingBuf[24]                 = RxBuf[52];
000198  4802              LDR      r0,|L6.420|
00019a  3020              ADDS     r0,r0,#0x20
00019c  7d00              LDRB     r0,[r0,#0x14]  ; RxBuf
00019e  8608              STRH     r0,[r1,#0x30]
;;;512    }
0001a0  4770              BX       lr
;;;513    
                          ENDP

0001a2  0000              DCW      0x0000
                  |L6.420|
                          DCD      RxBuf
                  |L6.424|
                          DCD      usRegHoldingBuf

                          AREA ||i.MBHoldingRegWrite||, CODE, READONLY, ALIGN=2

                  MBHoldingRegWrite PROC
;;;514    //保持寄存器写更新
;;;515    void MBHoldingRegWrite(void)
000000  487c              LDR      r0,|L7.500|
;;;516    {
;;;517        TxBuf[1] = (u8bit)((*((u32bit *)(usRegHoldingBuf + 0)) >> 24) & 0XFF);      //传感器量程
000002  6800              LDR      r0,[r0,#0]  ; usRegHoldingBuf
000004  0e00              LSRS     r0,r0,#24
000006  497c              LDR      r1,|L7.504|
000008  7048              STRB     r0,[r1,#1]
;;;518        TxBuf[2] = (u8bit)((*((u32bit *)(usRegHoldingBuf + 0)) >> 16) & 0XFF);
00000a  487a              LDR      r0,|L7.500|
00000c  6800              LDR      r0,[r0,#0]  ; usRegHoldingBuf
00000e  0200              LSLS     r0,r0,#8
000010  0e00              LSRS     r0,r0,#24
000012  7088              STRB     r0,[r1,#2]
;;;519        TxBuf[3] = (u8bit)((*((u32bit *)(usRegHoldingBuf + 0)) >> 8) & 0XFF);
000014  4877              LDR      r0,|L7.500|
000016  8800              LDRH     r0,[r0,#0]  ; usRegHoldingBuf
000018  0400              LSLS     r0,r0,#16
00001a  0e00              LSRS     r0,r0,#24
00001c  70c8              STRB     r0,[r1,#3]
;;;520        TxBuf[4] = (u8bit)((*((u32bit *)(usRegHoldingBuf + 0)) >> 0) & 0XFF);
00001e  4875              LDR      r0,|L7.500|
000020  7800              LDRB     r0,[r0,#0]  ; usRegHoldingBuf
000022  7108              STRB     r0,[r1,#4]
;;;521    
;;;522        TxBuf[5] = (u8bit)((*((u32bit *)(usRegHoldingBuf + 2)) >> 24) & 0XFF);      //砝码输出值(AD得到)
000024  4873              LDR      r0,|L7.500|
000026  6840              LDR      r0,[r0,#4]  ; usRegHoldingBuf
000028  0e00              LSRS     r0,r0,#24
00002a  7148              STRB     r0,[r1,#5]
;;;523        TxBuf[6] = (u8bit)((*((u32bit *)(usRegHoldingBuf + 2)) >> 16) & 0XFF);
00002c  4871              LDR      r0,|L7.500|
00002e  6840              LDR      r0,[r0,#4]  ; usRegHoldingBuf
000030  0200              LSLS     r0,r0,#8
000032  0e00              LSRS     r0,r0,#24
000034  7188              STRB     r0,[r1,#6]
;;;524        TxBuf[7] = (u8bit)((*((u32bit *)(usRegHoldingBuf + 2)) >> 8) & 0XFF);
000036  486f              LDR      r0,|L7.500|
000038  8880              LDRH     r0,[r0,#4]  ; usRegHoldingBuf
00003a  0400              LSLS     r0,r0,#16
00003c  0e00              LSRS     r0,r0,#24
00003e  71c8              STRB     r0,[r1,#7]
;;;525        TxBuf[8] = (u8bit)((*((u32bit *)(usRegHoldingBuf + 2)) >> 0) & 0XFF);
000040  486c              LDR      r0,|L7.500|
000042  7900              LDRB     r0,[r0,#4]  ; usRegHoldingBuf
000044  7208              STRB     r0,[r1,#8]
;;;526    
;;;527        TxBuf[9]  = (u8bit)((*((u32bit *)(usRegHoldingBuf + 4)) >> 24) & 0XFF);      //砝码值
000046  486b              LDR      r0,|L7.500|
000048  6880              LDR      r0,[r0,#8]  ; usRegHoldingBuf
00004a  0e00              LSRS     r0,r0,#24
00004c  7248              STRB     r0,[r1,#9]
;;;528        TxBuf[10] = (u8bit)((*((u32bit *)(usRegHoldingBuf + 4)) >> 16) & 0XFF);
00004e  4869              LDR      r0,|L7.500|
000050  6880              LDR      r0,[r0,#8]  ; usRegHoldingBuf
000052  0200              LSLS     r0,r0,#8
000054  0e00              LSRS     r0,r0,#24
000056  7288              STRB     r0,[r1,#0xa]
;;;529        TxBuf[11] = (u8bit)((*((u32bit *)(usRegHoldingBuf + 4)) >> 8) & 0XFF);
000058  4866              LDR      r0,|L7.500|
00005a  8900              LDRH     r0,[r0,#8]  ; usRegHoldingBuf
00005c  0400              LSLS     r0,r0,#16
00005e  0e00              LSRS     r0,r0,#24
000060  72c8              STRB     r0,[r1,#0xb]
;;;530        TxBuf[12] = (u8bit)((*((u32bit *)(usRegHoldingBuf + 4)) >> 0) & 0XFF);
000062  4864              LDR      r0,|L7.500|
000064  7a00              LDRB     r0,[r0,#8]  ; usRegHoldingBuf
000066  7308              STRB     r0,[r1,#0xc]
;;;531    
;;;532        TxBuf[13] = (u8bit)((*((u32bit *)(usRegHoldingBuf + 6)) >> 24) & 0XFF);      //皮重
000068  4862              LDR      r0,|L7.500|
00006a  68c0              LDR      r0,[r0,#0xc]  ; usRegHoldingBuf
00006c  0e00              LSRS     r0,r0,#24
00006e  7348              STRB     r0,[r1,#0xd]
;;;533        TxBuf[14] = (u8bit)((*((u32bit *)(usRegHoldingBuf + 6)) >> 16) & 0XFF);
000070  4860              LDR      r0,|L7.500|
000072  68c0              LDR      r0,[r0,#0xc]  ; usRegHoldingBuf
000074  0200              LSLS     r0,r0,#8
000076  0e00              LSRS     r0,r0,#24
000078  7388              STRB     r0,[r1,#0xe]
;;;534        TxBuf[15] = (u8bit)((*((u32bit *)(usRegHoldingBuf + 6)) >> 8) & 0XFF);
00007a  485e              LDR      r0,|L7.500|
00007c  8980              LDRH     r0,[r0,#0xc]  ; usRegHoldingBuf
00007e  0400              LSLS     r0,r0,#16
000080  0e00              LSRS     r0,r0,#24
000082  73c8              STRB     r0,[r1,#0xf]
;;;535        TxBuf[16] = (u8bit)((*((u32bit *)(usRegHoldingBuf + 6)) >> 0) & 0XFF);
000084  485b              LDR      r0,|L7.500|
000086  7b00              LDRB     r0,[r0,#0xc]  ; usRegHoldingBuf
000088  7408              STRB     r0,[r1,#0x10]
;;;536    
;;;537        TxBuf[17] = (u8bit)((*((u32bit *)(usRegHoldingBuf + 8)) >> 24) & 0XFF);      //掉包计数器
00008a  485a              LDR      r0,|L7.500|
00008c  6900              LDR      r0,[r0,#0x10]  ; usRegHoldingBuf
00008e  0e00              LSRS     r0,r0,#24
000090  7448              STRB     r0,[r1,#0x11]
;;;538        TxBuf[18] = (u8bit)((*((u32bit *)(usRegHoldingBuf + 8)) >> 16) & 0XFF);
000092  4858              LDR      r0,|L7.500|
000094  6900              LDR      r0,[r0,#0x10]  ; usRegHoldingBuf
000096  0200              LSLS     r0,r0,#8
000098  0e00              LSRS     r0,r0,#24
00009a  7488              STRB     r0,[r1,#0x12]
;;;539        TxBuf[19] = (u8bit)((*((u32bit *)(usRegHoldingBuf + 8)) >> 8) & 0XFF);
00009c  4855              LDR      r0,|L7.500|
00009e  8a00              LDRH     r0,[r0,#0x10]  ; usRegHoldingBuf
0000a0  0400              LSLS     r0,r0,#16
0000a2  0e00              LSRS     r0,r0,#24
0000a4  74c8              STRB     r0,[r1,#0x13]
;;;540        TxBuf[20] = (u8bit)((*((u32bit *)(usRegHoldingBuf + 8)) >> 0) & 0XFF);
0000a6  4853              LDR      r0,|L7.500|
0000a8  7c00              LDRB     r0,[r0,#0x10]  ; usRegHoldingBuf
0000aa  7508              STRB     r0,[r1,#0x14]
;;;541    
;;;542        TxBuf[21] = (u8bit)((*((u16bit *)(usRegHoldingBuf + 10)) >> 8) & 0XFF);
0000ac  4851              LDR      r0,|L7.500|
0000ae  8a80              LDRH     r0,[r0,#0x14]  ; usRegHoldingBuf
0000b0  1200              ASRS     r0,r0,#8
0000b2  7548              STRB     r0,[r1,#0x15]
;;;543        TxBuf[22] = (u8bit)((*((u16bit *)(usRegHoldingBuf + 10)) >> 0) & 0XFF);
0000b4  484f              LDR      r0,|L7.500|
0000b6  7d00              LDRB     r0,[r0,#0x14]  ; usRegHoldingBuf
0000b8  7588              STRB     r0,[r1,#0x16]
;;;544    
;;;545        TxBuf[23] = (u8bit)((*((u16bit *)(usRegHoldingBuf + 11)) >> 8) & 0XFF);
0000ba  484e              LDR      r0,|L7.500|
0000bc  8ac0              LDRH     r0,[r0,#0x16]  ; usRegHoldingBuf
0000be  1200              ASRS     r0,r0,#8
0000c0  75c8              STRB     r0,[r1,#0x17]
;;;546        TxBuf[24] = (u8bit)((*((u16bit *)(usRegHoldingBuf + 11)) >> 0) & 0XFF);
0000c2  484c              LDR      r0,|L7.500|
0000c4  7d80              LDRB     r0,[r0,#0x16]  ; usRegHoldingBuf
0000c6  7608              STRB     r0,[r1,#0x18]
;;;547    
;;;548        TxBuf[25] = (u8bit)((*((u16bit *)(usRegHoldingBuf + 12)) >> 8) & 0XFF);
0000c8  484a              LDR      r0,|L7.500|
0000ca  8b00              LDRH     r0,[r0,#0x18]  ; usRegHoldingBuf
0000cc  1200              ASRS     r0,r0,#8
0000ce  7648              STRB     r0,[r1,#0x19]
;;;549        TxBuf[26] = (u8bit)((*((u16bit *)(usRegHoldingBuf + 12)) >> 0) & 0XFF);
0000d0  4848              LDR      r0,|L7.500|
0000d2  7e00              LDRB     r0,[r0,#0x18]  ; usRegHoldingBuf
0000d4  7688              STRB     r0,[r1,#0x1a]
;;;550    
;;;551        TxBuf[27] = (u8bit)((*((u16bit *)(usRegHoldingBuf + 13)) >> 8) & 0XFF);
0000d6  4847              LDR      r0,|L7.500|
0000d8  8b40              LDRH     r0,[r0,#0x1a]  ; usRegHoldingBuf
0000da  1200              ASRS     r0,r0,#8
0000dc  76c8              STRB     r0,[r1,#0x1b]
;;;552        TxBuf[28] = (u8bit)((*((u16bit *)(usRegHoldingBuf + 13)) >> 0) & 0XFF);
0000de  4845              LDR      r0,|L7.500|
0000e0  7e80              LDRB     r0,[r0,#0x1a]  ; usRegHoldingBuf
0000e2  7708              STRB     r0,[r1,#0x1c]
;;;553    
;;;554        TxBuf[29] = (u8bit)((*((u16bit *)(usRegHoldingBuf + 14)) >> 8) & 0XFF);
0000e4  4843              LDR      r0,|L7.500|
0000e6  8b80              LDRH     r0,[r0,#0x1c]  ; usRegHoldingBuf
0000e8  1200              ASRS     r0,r0,#8
0000ea  7748              STRB     r0,[r1,#0x1d]
;;;555        TxBuf[30] = (u8bit)((*((u16bit *)(usRegHoldingBuf + 14)) >> 0) & 0XFF);
0000ec  4841              LDR      r0,|L7.500|
0000ee  7f00              LDRB     r0,[r0,#0x1c]  ; usRegHoldingBuf
0000f0  7788              STRB     r0,[r1,#0x1e]
;;;556    
;;;557        TxBuf[31] = (u8bit)(usRegHoldingBuf[15] & 0XFF);
0000f2  4840              LDR      r0,|L7.500|
0000f4  7f80              LDRB     r0,[r0,#0x1e]  ; usRegHoldingBuf
0000f6  77c8              STRB     r0,[r1,#0x1f]
;;;558    
;;;559        TxBuf[32] = (u8bit)(usRegHoldingBuf[16] & 0XFF);
0000f8  483e              LDR      r0,|L7.500|
0000fa  8c00              LDRH     r0,[r0,#0x20]  ; usRegHoldingBuf
0000fc  b2c1              UXTB     r1,r0
0000fe  483e              LDR      r0,|L7.504|
000100  3020              ADDS     r0,r0,#0x20
000102  7001              STRB     r1,[r0,#0]
;;;560    
;;;561        TxBuf[33] = (u8bit)(usRegHoldingBuf[17] & 0XFF);
000104  483b              LDR      r0,|L7.500|
000106  8c40              LDRH     r0,[r0,#0x22]  ; usRegHoldingBuf
000108  b2c1              UXTB     r1,r0
00010a  483b              LDR      r0,|L7.504|
00010c  3020              ADDS     r0,r0,#0x20
00010e  7041              STRB     r1,[r0,#1]
;;;562    
;;;563        if(usRegHoldingBuf[18])      TxBuf[34] |= (u8bit)BIT4;
000110  4838              LDR      r0,|L7.500|
000112  8c80              LDRH     r0,[r0,#0x24]  ; usRegHoldingBuf
000114  2800              CMP      r0,#0
000116  d008              BEQ      |L7.298|
000118  4837              LDR      r0,|L7.504|
00011a  3020              ADDS     r0,r0,#0x20
00011c  7880              LDRB     r0,[r0,#2]  ; TxBuf
00011e  2110              MOVS     r1,#0x10
000120  4308              ORRS     r0,r0,r1
000122  4935              LDR      r1,|L7.504|
000124  3120              ADDS     r1,r1,#0x20
000126  7088              STRB     r0,[r1,#2]
000128  e007              B        |L7.314|
                  |L7.298|
;;;564        else      TxBuf[34] &= ~(u8bit)BIT4;
00012a  4833              LDR      r0,|L7.504|
00012c  3020              ADDS     r0,r0,#0x20
00012e  7880              LDRB     r0,[r0,#2]  ; TxBuf
000130  2110              MOVS     r1,#0x10
000132  4388              BICS     r0,r0,r1
000134  4930              LDR      r1,|L7.504|
000136  3120              ADDS     r1,r1,#0x20
000138  7088              STRB     r0,[r1,#2]
                  |L7.314|
;;;565        if(usRegHoldingBuf[19])      TxBuf[34] |= (u8bit)BIT5;
00013a  482e              LDR      r0,|L7.500|
00013c  8cc0              LDRH     r0,[r0,#0x26]  ; usRegHoldingBuf
00013e  2800              CMP      r0,#0
000140  d008              BEQ      |L7.340|
000142  482d              LDR      r0,|L7.504|
000144  3020              ADDS     r0,r0,#0x20
000146  7880              LDRB     r0,[r0,#2]  ; TxBuf
000148  2120              MOVS     r1,#0x20
00014a  4308              ORRS     r0,r0,r1
00014c  492a              LDR      r1,|L7.504|
00014e  3120              ADDS     r1,r1,#0x20
000150  7088              STRB     r0,[r1,#2]
000152  e007              B        |L7.356|
                  |L7.340|
;;;566        else      TxBuf[34] &= ~(u8bit)BIT5;
000154  4828              LDR      r0,|L7.504|
000156  3020              ADDS     r0,r0,#0x20
000158  7880              LDRB     r0,[r0,#2]  ; TxBuf
00015a  2120              MOVS     r1,#0x20
00015c  4388              BICS     r0,r0,r1
00015e  4926              LDR      r1,|L7.504|
000160  3120              ADDS     r1,r1,#0x20
000162  7088              STRB     r0,[r1,#2]
                  |L7.356|
;;;567        if(usRegHoldingBuf[20])      TxBuf[34] |= (u8bit)BIT6;
000164  4823              LDR      r0,|L7.500|
000166  8d00              LDRH     r0,[r0,#0x28]  ; usRegHoldingBuf
000168  2800              CMP      r0,#0
00016a  d008              BEQ      |L7.382|
00016c  4822              LDR      r0,|L7.504|
00016e  3020              ADDS     r0,r0,#0x20
000170  7880              LDRB     r0,[r0,#2]  ; TxBuf
000172  2140              MOVS     r1,#0x40
000174  4308              ORRS     r0,r0,r1
000176  4920              LDR      r1,|L7.504|
000178  3120              ADDS     r1,r1,#0x20
00017a  7088              STRB     r0,[r1,#2]
00017c  e007              B        |L7.398|
                  |L7.382|
;;;568        else      TxBuf[34] &= ~(u8bit)BIT6;
00017e  481e              LDR      r0,|L7.504|
000180  3020              ADDS     r0,r0,#0x20
000182  7880              LDRB     r0,[r0,#2]  ; TxBuf
000184  2140              MOVS     r1,#0x40
000186  4388              BICS     r0,r0,r1
000188  491b              LDR      r1,|L7.504|
00018a  3120              ADDS     r1,r1,#0x20
00018c  7088              STRB     r0,[r1,#2]
                  |L7.398|
;;;569        if(usRegHoldingBuf[21])      TxBuf[34] |= (u8bit)BIT7;
00018e  4819              LDR      r0,|L7.500|
000190  8d40              LDRH     r0,[r0,#0x2a]  ; usRegHoldingBuf
000192  2800              CMP      r0,#0
000194  d008              BEQ      |L7.424|
000196  4818              LDR      r0,|L7.504|
000198  3020              ADDS     r0,r0,#0x20
00019a  7880              LDRB     r0,[r0,#2]  ; TxBuf
00019c  2180              MOVS     r1,#0x80
00019e  4308              ORRS     r0,r0,r1
0001a0  4915              LDR      r1,|L7.504|
0001a2  3120              ADDS     r1,r1,#0x20
0001a4  7088              STRB     r0,[r1,#2]
0001a6  e007              B        |L7.440|
                  |L7.424|
;;;570        else      TxBuf[34] &= ~(u8bit)BIT7;
0001a8  4813              LDR      r0,|L7.504|
0001aa  3020              ADDS     r0,r0,#0x20
0001ac  7880              LDRB     r0,[r0,#2]  ; TxBuf
0001ae  2180              MOVS     r1,#0x80
0001b0  4388              BICS     r0,r0,r1
0001b2  4911              LDR      r1,|L7.504|
0001b4  3120              ADDS     r1,r1,#0x20
0001b6  7088              STRB     r0,[r1,#2]
                  |L7.440|
;;;571    
;;;572        TxBuf[35] = SetDoneFlag.u8bitSD;
0001b8  4810              LDR      r0,|L7.508|
0001ba  7801              LDRB     r1,[r0,#0]  ; SetDoneFlag
0001bc  480e              LDR      r0,|L7.504|
0001be  3020              ADDS     r0,r0,#0x20
0001c0  70c1              STRB     r1,[r0,#3]
;;;573        TxBuf[36] = SetDoneFlag1.u8bitSD;
0001c2  480f              LDR      r0,|L7.512|
0001c4  7801              LDRB     r1,[r0,#0]  ; SetDoneFlag1
0001c6  480c              LDR      r0,|L7.504|
0001c8  3020              ADDS     r0,r0,#0x20
0001ca  7101              STRB     r1,[r0,#4]
;;;574        TxBuf[37] = (u8bit)(usRegHoldingBuf[22] & 0XFF);
0001cc  4809              LDR      r0,|L7.500|
0001ce  8d80              LDRH     r0,[r0,#0x2c]  ; usRegHoldingBuf
0001d0  b2c1              UXTB     r1,r0
0001d2  4809              LDR      r0,|L7.504|
0001d4  3020              ADDS     r0,r0,#0x20
0001d6  7141              STRB     r1,[r0,#5]
;;;575        TxBuf[38] = (u8bit)(usRegHoldingBuf[23] & 0XFF);
0001d8  4806              LDR      r0,|L7.500|
0001da  8dc0              LDRH     r0,[r0,#0x2e]  ; usRegHoldingBuf
0001dc  b2c1              UXTB     r1,r0
0001de  4806              LDR      r0,|L7.504|
0001e0  3020              ADDS     r0,r0,#0x20
0001e2  7181              STRB     r1,[r0,#6]
;;;576        TxBuf[39] = (u8bit)(usRegHoldingBuf[24] & 0XFF);
0001e4  4803              LDR      r0,|L7.500|
0001e6  8e00              LDRH     r0,[r0,#0x30]  ; usRegHoldingBuf
0001e8  b2c1              UXTB     r1,r0
0001ea  4803              LDR      r0,|L7.504|
0001ec  3020              ADDS     r0,r0,#0x20
0001ee  71c1              STRB     r1,[r0,#7]
;;;577        
;;;578    }
0001f0  4770              BX       lr
;;;579    //线圈读更新
                          ENDP

0001f2  0000              DCW      0x0000
                  |L7.500|
                          DCD      usRegHoldingBuf
                  |L7.504|
                          DCD      TxBuf
                  |L7.508|
                          DCD      SetDoneFlag
                  |L7.512|
                          DCD      SetDoneFlag1

                          AREA ||i.MBInputRegRead||, CODE, READONLY, ALIGN=2

                  MBInputRegRead PROC
;;;467    //输入寄存器读更新
;;;468    void MBInputRegRead(void)
000000  481d              LDR      r0,|L8.120|
;;;469    {
;;;470        *((u32bit *)usRegInputBuf)          = (RxBuf[1]<<24) + (RxBuf[2]<<16)
000002  7840              LDRB     r0,[r0,#1]  ; RxBuf
000004  0600              LSLS     r0,r0,#24
000006  491c              LDR      r1,|L8.120|
000008  7889              LDRB     r1,[r1,#2]  ; RxBuf
00000a  0409              LSLS     r1,r1,#16
00000c  1840              ADDS     r0,r0,r1
00000e  491a              LDR      r1,|L8.120|
000010  78c9              LDRB     r1,[r1,#3]  ; RxBuf
000012  0209              LSLS     r1,r1,#8
000014  1840              ADDS     r0,r0,r1
000016  4918              LDR      r1,|L8.120|
000018  7909              LDRB     r1,[r1,#4]  ; RxBuf
00001a  1840              ADDS     r0,r0,r1
00001c  4917              LDR      r1,|L8.124|
00001e  6008              STR      r0,[r1,#0]  ; usRegInputBuf
;;;471                                            + (RxBuf[3]<<8) + RxBuf[4];             //未标称变换的净重
;;;472        usRegInputBuf[2]                    = (RxBuf[5]<<8) + RxBuf[6];             //上包水泥重
000020  4815              LDR      r0,|L8.120|
000022  7940              LDRB     r0,[r0,#5]  ; RxBuf
000024  0200              LSLS     r0,r0,#8
000026  4914              LDR      r1,|L8.120|
000028  7989              LDRB     r1,[r1,#6]  ; RxBuf
00002a  1840              ADDS     r0,r0,r1
00002c  4913              LDR      r1,|L8.124|
00002e  8088              STRH     r0,[r1,#4]
;;;473        usRegInputBuf[3]                    = (RxBuf[7]<<8) + RxBuf[8];             //当前时重
000030  4811              LDR      r0,|L8.120|
000032  79c0              LDRB     r0,[r0,#7]  ; RxBuf
000034  0200              LSLS     r0,r0,#8
000036  4910              LDR      r1,|L8.120|
000038  7a09              LDRB     r1,[r1,#8]  ; RxBuf
00003a  1840              ADDS     r0,r0,r1
00003c  490f              LDR      r1,|L8.124|
00003e  80c8              STRH     r0,[r1,#6]
;;;474        usRegInputBuf[4]                    = *((u16bit *)(RxBuf + 42));            //参数错误报警
000040  480d              LDR      r0,|L8.120|
000042  8d40              LDRH     r0,[r0,#0x2a]  ; RxBuf
000044  8108              STRH     r0,[r1,#8]
;;;475        usRegInputBuf[5]                    = *((u16bit *)(RxBuf + 44));            //IO状态
000046  480c              LDR      r0,|L8.120|
000048  8d80              LDRH     r0,[r0,#0x2c]  ; RxBuf
00004a  8148              STRH     r0,[r1,#0xa]
;;;476        usRegInputBuf[6]                    = *((u16bit *)(RxBuf + 46)) & 0x00ff;   //IO状态
00004c  480a              LDR      r0,|L8.120|
00004e  8dc0              LDRH     r0,[r0,#0x2e]  ; RxBuf
000050  b2c0              UXTB     r0,r0
000052  8188              STRH     r0,[r1,#0xc]
;;;477        usRegInputBuf[7]                    = (RxBuf[27]<<8) + RxBuf[28];           //掉包计数器
000054  4808              LDR      r0,|L8.120|
000056  7ec0              LDRB     r0,[r0,#0x1b]  ; RxBuf
000058  0200              LSLS     r0,r0,#8
00005a  4907              LDR      r1,|L8.120|
00005c  7f09              LDRB     r1,[r1,#0x1c]  ; RxBuf
00005e  1840              ADDS     r0,r0,r1
000060  4906              LDR      r1,|L8.124|
000062  81c8              STRH     r0,[r1,#0xe]
;;;478        usRegInputBuf[8]                    = (RxBuf[25]<<8) + RxBuf[26];
000064  4804              LDR      r0,|L8.120|
000066  7e40              LDRB     r0,[r0,#0x19]  ; RxBuf
000068  0200              LSLS     r0,r0,#8
00006a  4903              LDR      r1,|L8.120|
00006c  7e89              LDRB     r1,[r1,#0x1a]  ; RxBuf
00006e  1840              ADDS     r0,r0,r1
000070  4902              LDR      r1,|L8.124|
000072  8208              STRH     r0,[r1,#0x10]
;;;479    }
000074  4770              BX       lr
;;;480    //保持寄存器读更新
                          ENDP

000076  0000              DCW      0x0000
                  |L8.120|
                          DCD      RxBuf
                  |L8.124|
                          DCD      usRegInputBuf

                          AREA ||i.Uart1Init||, CODE, READONLY, ALIGN=1

                  Uart1Init PROC
;;;20     
;;;21     void Uart1Init(u32bit BaudRate)
000000  b53e              PUSH     {r1-r5,lr}
;;;22     {
000002  4604              MOV      r4,r0
;;;23         STR_UART_T Uart1Param;
;;;24         /* UART Setting */
;;;25         Uart1Param.u32BaudRate      = BaudRate;                 //波特率115.2K
000004  9400              STR      r4,[sp,#0]
;;;26         Uart1Param.u8cDataBits      = DRVUART_DATABITS_8;       //8位数据位
000006  2103              MOVS     r1,#3
000008  4668              MOV      r0,sp
00000a  7101              STRB     r1,[r0,#4]
;;;27         Uart1Param.u8cStopBits      = DRVUART_STOPBITS_1;       //1位停止位
00000c  2100              MOVS     r1,#0
00000e  7141              STRB     r1,[r0,#5]
;;;28         Uart1Param.u8cParity        = DRVUART_PARITY_EVEN;      //偶校验
000010  2103              MOVS     r1,#3
000012  7181              STRB     r1,[r0,#6]
;;;29         Uart1Param.u8cRxTriggerLevel= DRVUART_FIFO_1BYTES;      //1字节数据缓冲区
000014  2100              MOVS     r1,#0
000016  71c1              STRB     r1,[r0,#7]
;;;30         /* Select UART Clock Source From 12Mhz*/
;;;31         DrvSYS_SelectIPClockSource(E_SYS_UART_CLKSRC,0); 
000018  2006              MOVS     r0,#6
00001a  f7fffffe          BL       DrvSYS_SelectIPClockSource
;;;32         DrvUART_Open(UART_PORT1, &Uart1Param);
00001e  4669              MOV      r1,sp
000020  2001              MOVS     r0,#1
000022  0500              LSLS     r0,r0,#20
000024  f7fffffe          BL       DrvUART_Open
;;;33     }
000028  bd3e              POP      {r1-r5,pc}
;;;34     
                          ENDP


                          AREA ||i.Uart1Receive||, CODE, READONLY, ALIGN=2

                  Uart1Receive PROC
;;;43     
;;;44     u8bit Uart1Receive(u8bit *ch)
000000  4601              MOV      r1,r0
;;;45     {
;;;46     
;;;47         while(UART1->FSR.RX_EMPTY);
000002  bf00              NOP      
                  |L10.4|
000004  480c              LDR      r0,|L10.56|
000006  6980              LDR      r0,[r0,#0x18]
000008  0440              LSLS     r0,r0,#17
00000a  0fc0              LSRS     r0,r0,#31
00000c  2800              CMP      r0,#0
00000e  d1f9              BNE      |L10.4|
;;;48     
;;;49         if(UART1->FSR.PEF){
000010  4809              LDR      r0,|L10.56|
000012  6980              LDR      r0,[r0,#0x18]
000014  06c0              LSLS     r0,r0,#27
000016  0fc0              LSRS     r0,r0,#31
000018  2800              CMP      r0,#0
00001a  d008              BEQ      |L10.46|
;;;50             UART1->FSR.PEF = 1;                                 //复位奇偶校验标志
00001c  4806              LDR      r0,|L10.56|
00001e  6980              LDR      r0,[r0,#0x18]
000020  2210              MOVS     r2,#0x10
000022  4390              BICS     r0,r0,r2
000024  3010              ADDS     r0,r0,#0x10
000026  4a04              LDR      r2,|L10.56|
000028  6190              STR      r0,[r2,#0x18]
;;;51             return PE_Err;
00002a  2002              MOVS     r0,#2
                  |L10.44|
;;;52         }
;;;53         *ch = UART1->DATA;                                      //接收一个字符送串口输入缓冲区
;;;54         return DATA_OK;
;;;55     }
00002c  4770              BX       lr
                  |L10.46|
00002e  4802              LDR      r0,|L10.56|
000030  6800              LDR      r0,[r0,#0]            ;53
000032  7008              STRB     r0,[r1,#0]            ;53
000034  2000              MOVS     r0,#0                 ;54
000036  e7f9              B        |L10.44|
;;;56     
                          ENDP

                  |L10.56|
                          DCD      0x40150000

                          AREA ||i.Uart1Send||, CODE, READONLY, ALIGN=2

                  Uart1Send PROC
;;;35     
;;;36     u8bit Uart1Send(u8bit ch)
000000  bf00              NOP      
                  |L11.2|
;;;37     {  
;;;38         while (UART1->FSR.TE_FLAG !=1);
000002  4904              LDR      r1,|L11.20|
000004  6989              LDR      r1,[r1,#0x18]
000006  00c9              LSLS     r1,r1,#3
000008  0fc9              LSRS     r1,r1,#31
00000a  2900              CMP      r1,#0
00000c  d0f9              BEQ      |L11.2|
;;;39         UART1->DATA = ch;                                       /* Send UART Data from buffer */
00000e  4901              LDR      r1,|L11.20|
000010  6008              STR      r0,[r1,#0]
;;;40         return ch;
;;;41     }
000012  4770              BX       lr
;;;42     
                          ENDP

                  |L11.20|
                          DCD      0x40150000

                          AREA ||i.eMBRegCoilsCB||, CODE, READONLY, ALIGN=2

                  eMBRegCoilsCB PROC
;;;388    eMBErrorCode
;;;389    eMBRegCoilsCB( UCHAR * pucRegBuffer, USHORT usAddress, USHORT usNCoils, eMBRegisterMode eMode )
000000  b5ff              PUSH     {r0-r7,lr}
;;;390    {
000002  b083              SUB      sp,sp,#0xc
000004  4605              MOV      r5,r0
000006  460f              MOV      r7,r1
000008  4614              MOV      r4,r2
;;;391        eMBErrorCode    eStatus = MB_ENOERR;
00000a  2000              MOVS     r0,#0
00000c  9002              STR      r0,[sp,#8]
;;;392        int             iRegIndex;
;;;393    
;;;394    	if( ( usAddress >= REG_COILS_START ) &&
00000e  2f01              CMP      r7,#1
000010  db48              BLT      |L12.164|
;;;395    		( usAddress + usNCoils <= REG_COILS_START + REG_COILS_NREGS ) ){
000012  1938              ADDS     r0,r7,r4
000014  2809              CMP      r0,#9
000016  dc45              BGT      |L12.164|
;;;396    		iRegIndex = ( int )( usAddress - usRegCoilsStart );
000018  4825              LDR      r0,|L12.176|
00001a  8800              LDRH     r0,[r0,#0]  ; usRegCoilsStart
00001c  1a3e              SUBS     r6,r7,r0
;;;397    		switch ( eMode ){
00001e  9806              LDR      r0,[sp,#0x18]
000020  2800              CMP      r0,#0
000022  d002              BEQ      |L12.42|
000024  2801              CMP      r0,#1
000026  d13c              BNE      |L12.162|
000028  e01b              B        |L12.98|
                  |L12.42|
;;;398    			/* Pass current register values to the protocol stack. */
;;;399    		case MB_REG_READ:
;;;400    			MBCoilsRead();
00002a  f7fffffe          BL       MBCoilsRead
;;;401    			while( usNCoils > 0 ){
00002e  e015              B        |L12.92|
                  |L12.48|
;;;402    				if(usNCoils >= 8){
000030  2c08              CMP      r4,#8
000032  db0b              BLT      |L12.76|
;;;403    					*pucRegBuffer++ = xMBUtilGetBits(usRegCoilsBuf,iRegIndex,8);
000034  b2b1              UXTH     r1,r6
000036  2208              MOVS     r2,#8
000038  481e              LDR      r0,|L12.180|
00003a  f7fffffe          BL       xMBUtilGetBits
00003e  7028              STRB     r0,[r5,#0]
000040  1c6d              ADDS     r5,r5,#1
;;;404    					iRegIndex += 8;
000042  3608              ADDS     r6,r6,#8
;;;405    					usNCoils -= 8;
000044  4620              MOV      r0,r4
000046  3808              SUBS     r0,r0,#8
000048  b284              UXTH     r4,r0
00004a  e007              B        |L12.92|
                  |L12.76|
;;;406    				}
;;;407    				else{
;;;408    					*pucRegBuffer++ = xMBUtilGetBits(usRegCoilsBuf,iRegIndex,usNCoils);
00004c  b2e2              UXTB     r2,r4
00004e  b2b1              UXTH     r1,r6
000050  4818              LDR      r0,|L12.180|
000052  f7fffffe          BL       xMBUtilGetBits
000056  7028              STRB     r0,[r5,#0]
000058  1c6d              ADDS     r5,r5,#1
;;;409    					usNCoils = 0;
00005a  2400              MOVS     r4,#0
                  |L12.92|
00005c  2c00              CMP      r4,#0                 ;401
00005e  dce7              BGT      |L12.48|
;;;410    				}
;;;411    			}
;;;412    			break;
000060  e01f              B        |L12.162|
                  |L12.98|
;;;413    
;;;414                /* Update current register values with new values from the
;;;415                 * protocol stack. */
;;;416    		case MB_REG_WRITE:
;;;417    			while( usNCoils > 0 ){
000062  e019              B        |L12.152|
                  |L12.100|
;;;418    				if(usNCoils >= 8){
000064  2c08              CMP      r4,#8
000066  db0d              BLT      |L12.132|
;;;419    					xMBUtilSetBits(usRegCoilsBuf,iRegIndex,8,*pucRegBuffer++);
000068  782b              LDRB     r3,[r5,#0]
00006a  1c6d              ADDS     r5,r5,#1
00006c  b2b0              UXTH     r0,r6
00006e  2208              MOVS     r2,#8
000070  4601              MOV      r1,r0
000072  9001              STR      r0,[sp,#4]
000074  480f              LDR      r0,|L12.180|
000076  f7fffffe          BL       xMBUtilSetBits
;;;420    					iRegIndex += 8;
00007a  3608              ADDS     r6,r6,#8
;;;421    					usNCoils -= 8;
00007c  4620              MOV      r0,r4
00007e  3808              SUBS     r0,r0,#8
000080  b284              UXTH     r4,r0
000082  e009              B        |L12.152|
                  |L12.132|
;;;422    				}
;;;423    				else{
;;;424    					xMBUtilSetBits(usRegCoilsBuf,iRegIndex,usNCoils,*pucRegBuffer++);
000084  782b              LDRB     r3,[r5,#0]
000086  1c6d              ADDS     r5,r5,#1
000088  b2e2              UXTB     r2,r4
00008a  b2b0              UXTH     r0,r6
00008c  4601              MOV      r1,r0
00008e  9001              STR      r0,[sp,#4]
000090  4808              LDR      r0,|L12.180|
000092  f7fffffe          BL       xMBUtilSetBits
;;;425    					usNCoils = 0;
000096  2400              MOVS     r4,#0
                  |L12.152|
000098  2c00              CMP      r4,#0                 ;417
00009a  dce3              BGT      |L12.100|
;;;426    				}
;;;427    			}
;;;428    			MBCoilsWrite();
00009c  f7fffffe          BL       MBCoilsWrite
0000a0  bf00              NOP                            ;397
                  |L12.162|
0000a2  e001              B        |L12.168|
                  |L12.164|
;;;429    		}
;;;430    	}
;;;431    	else{
;;;432    		eStatus = MB_ENOREG;
0000a4  2001              MOVS     r0,#1
0000a6  9002              STR      r0,[sp,#8]
                  |L12.168|
;;;433    	}
;;;434    	return eStatus;
0000a8  9802              LDR      r0,[sp,#8]
;;;435    }
0000aa  b007              ADD      sp,sp,#0x1c
0000ac  bdf0              POP      {r4-r7,pc}
;;;436    //离散量输入刷新回调函数
                          ENDP

0000ae  0000              DCW      0x0000
                  |L12.176|
                          DCD      usRegCoilsStart
                  |L12.180|
                          DCD      usRegCoilsBuf

                          AREA ||i.eMBRegDiscreteCB||, CODE, READONLY, ALIGN=2

                  eMBRegDiscreteCB PROC
;;;437    eMBErrorCode
;;;438    eMBRegDiscreteCB( UCHAR * pucRegBuffer, USHORT usAddress, USHORT usNDiscrete )
000000  b5f8              PUSH     {r3-r7,lr}
;;;439    {
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
000006  4614              MOV      r4,r2
;;;440        eMBErrorCode    eStatus = MB_ENOERR;
000008  2000              MOVS     r0,#0
00000a  9000              STR      r0,[sp,#0]
;;;441        int             iRegIndex;
;;;442    
;;;443        if((usAddress >= REG_INPUT_START)
00000c  2e01              CMP      r6,#1
00000e  db21              BLT      |L13.84|
;;;444            && (usAddress + usNDiscrete <= REG_DISCRETE_START + REG_DISCRETE_NREGS)){
000010  1930              ADDS     r0,r6,r4
000012  2831              CMP      r0,#0x31
000014  dc1e              BGT      |L13.84|
;;;445            MBDiscreteRead();
000016  f7fffffe          BL       MBDiscreteRead
;;;446            iRegIndex = ( int )( usAddress - usRegDiscreteStart );
00001a  4810              LDR      r0,|L13.92|
00001c  8800              LDRH     r0,[r0,#0]  ; usRegDiscreteStart
00001e  1a37              SUBS     r7,r6,r0
;;;447            while( usNDiscrete > 0 ){
000020  e015              B        |L13.78|
                  |L13.34|
;;;448                if(usNDiscrete >= 8){
000022  2c08              CMP      r4,#8
000024  db0b              BLT      |L13.62|
;;;449                    *pucRegBuffer++ = xMBUtilGetBits(usRegDiscreteBuf,iRegIndex,8);
000026  b2b9              UXTH     r1,r7
000028  2208              MOVS     r2,#8
00002a  480d              LDR      r0,|L13.96|
00002c  f7fffffe          BL       xMBUtilGetBits
000030  7028              STRB     r0,[r5,#0]
000032  1c6d              ADDS     r5,r5,#1
;;;450                    iRegIndex += 8;
000034  3708              ADDS     r7,r7,#8
;;;451                    usNDiscrete -= 8;
000036  4620              MOV      r0,r4
000038  3808              SUBS     r0,r0,#8
00003a  b284              UXTH     r4,r0
00003c  e007              B        |L13.78|
                  |L13.62|
;;;452                }
;;;453                else{
;;;454                    *pucRegBuffer++ = xMBUtilGetBits(usRegDiscreteBuf,iRegIndex,usNDiscrete);
00003e  b2e2              UXTB     r2,r4
000040  b2b9              UXTH     r1,r7
000042  4807              LDR      r0,|L13.96|
000044  f7fffffe          BL       xMBUtilGetBits
000048  7028              STRB     r0,[r5,#0]
00004a  1c6d              ADDS     r5,r5,#1
;;;455                    usNDiscrete = 0;
00004c  2400              MOVS     r4,#0
                  |L13.78|
00004e  2c00              CMP      r4,#0                 ;447
000050  dce7              BGT      |L13.34|
000052  e001              B        |L13.88|
                  |L13.84|
;;;456                }
;;;457            }
;;;458        }
;;;459        else{
;;;460            eStatus = MB_ENOREG;
000054  2001              MOVS     r0,#1
000056  9000              STR      r0,[sp,#0]
                  |L13.88|
;;;461        }
;;;462        return eStatus;
000058  9800              LDR      r0,[sp,#0]
;;;463    }
00005a  bdf8              POP      {r3-r7,pc}
;;;464    
                          ENDP

                  |L13.92|
                          DCD      usRegDiscreteStart
                  |L13.96|
                          DCD      usRegDiscreteBuf

                          AREA ||i.eMBRegHoldingCB||, CODE, READONLY, ALIGN=2

                  eMBRegHoldingCB PROC
;;;306    eMBErrorCode
;;;307    eMBRegHoldingCB( UCHAR * pucRegBuffer, USHORT usAddress, USHORT usNRegs, eMBRegisterMode eMode )
000000  b5f8              PUSH     {r3-r7,lr}
;;;308    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  461e              MOV      r6,r3
;;;309        eMBErrorCode    eStatus = MB_ENOERR;
000008  2000              MOVS     r0,#0
00000a  9000              STR      r0,[sp,#0]
;;;310        int             iRegIndex;
;;;311    
;;;312        if( ( usAddress >= REG_HOLDING_START ) &&
00000c  2d01              CMP      r5,#1
00000e  db74              BLT      |L14.250|
;;;313            ( usAddress + usNRegs <= REG_HOLDING_START + REG_HOLDING_NREGS ) ){
000010  18a8              ADDS     r0,r5,r2
000012  281d              CMP      r0,#0x1d
000014  dc71              BGT      |L14.250|
;;;314            iRegIndex = ( int )( usAddress - usRegHoldingStart );
000016  484c              LDR      r0,|L14.328|
000018  8800              LDRH     r0,[r0,#0]  ; usRegHoldingStart
00001a  1a2f              SUBS     r7,r5,r0
;;;315            switch ( eMode ){
00001c  2e00              CMP      r6,#0
00001e  d002              BEQ      |L14.38|
000020  2e01              CMP      r6,#1
000022  d112              BNE      |L14.74|
000024  e012              B        |L14.76|
                  |L14.38|
;;;316                /* Pass current register values to the protocol stack. */
;;;317            case MB_REG_READ:
;;;318                MBHoldingRegRead();
000026  f7fffffe          BL       MBHoldingRegRead
;;;319                while( usNRegs > 0 ){
00002a  e00c              B        |L14.70|
                  |L14.44|
;;;320                    *pucRegBuffer++ = ( UCHAR ) ( usRegHoldingBuf[iRegIndex] >> 8 );
00002c  0078              LSLS     r0,r7,#1
00002e  4947              LDR      r1,|L14.332|
000030  5a08              LDRH     r0,[r1,r0]
000032  1200              ASRS     r0,r0,#8
000034  7020              STRB     r0,[r4,#0]
000036  1c64              ADDS     r4,r4,#1
;;;321                    *pucRegBuffer++ = ( UCHAR ) ( usRegHoldingBuf[iRegIndex] & 0xFF );
000038  0078              LSLS     r0,r7,#1
00003a  5c08              LDRB     r0,[r1,r0]
00003c  7020              STRB     r0,[r4,#0]
00003e  1c64              ADDS     r4,r4,#1
;;;322                    iRegIndex++;
000040  1c7f              ADDS     r7,r7,#1
;;;323                    usNRegs--;
000042  1e50              SUBS     r0,r2,#1
000044  b282              UXTH     r2,r0
                  |L14.70|
000046  2a00              CMP      r2,#0                 ;319
000048  dcf0              BGT      |L14.44|
                  |L14.74|
;;;324                }
;;;325                break;
00004a  e077              B        |L14.316|
                  |L14.76|
;;;326    
;;;327                /* Update current register values with new values from the
;;;328                 * protocol stack. */
;;;329            case MB_REG_WRITE:
;;;330                while( usNRegs > 0 ){
00004c  e071              B        |L14.306|
                  |L14.78|
;;;331                    switch(iRegIndex){                          //参数更新标识刷新
00004e  003b              MOVS     r3,r7
000050  f7fffffe          BL       __ARM_common_switch8
000054  190e0f10          DCB      0x19,0x0e,0x0f,0x10
000058  1112135e          DCB      0x11,0x12,0x13,0x5e
00005c  5e1b1c25          DCB      0x5e,0x1b,0x1c,0x25
000060  2e373840          DCB      0x2e,0x37,0x38,0x40
000064  264a411d          DCB      0x26,0x4a,0x41,0x1d
000068  2f4b4254          DCB      0x2f,0x4b,0x42,0x54
00006c  55565e00          DCB      0x55,0x56,0x5e,0x00
;;;332                        case 0:
;;;333                        case 1:
000070  bf00              NOP      
;;;334                        case 2:
000072  bf00              NOP      
;;;335                        case 3:
000074  bf00              NOP      
;;;336                        case 4:
000076  bf00              NOP      
;;;337                        case 5:
000078  bf00              NOP      
;;;338                            SetDoneFlag.SD.SD3 = 1;             //标定参数需修改.
00007a  4835              LDR      r0,|L14.336|
00007c  7800              LDRB     r0,[r0,#0]  ; SetDoneFlag
00007e  2104              MOVS     r1,#4
000080  4388              BICS     r0,r0,r1
000082  1d00              ADDS     r0,r0,#4
000084  4932              LDR      r1,|L14.336|
000086  7008              STRB     r0,[r1,#0]
;;;339                            break;
000088  e042              B        |L14.272|
;;;340                        case 8:
;;;341                        case 9:
00008a  bf00              NOP      
;;;342                        case 18:
00008c  bf00              NOP      
;;;343                            SetDoneFlag.SD.SD6 = 1;             //掉包计数器需修改.
00008e  4830              LDR      r0,|L14.336|
000090  7800              LDRB     r0,[r0,#0]  ; SetDoneFlag
000092  2120              MOVS     r1,#0x20
000094  4388              BICS     r0,r0,r1
000096  3020              ADDS     r0,r0,#0x20
000098  492d              LDR      r1,|L14.336|
00009a  7008              STRB     r0,[r1,#0]
;;;344                            break;
00009c  e038              B        |L14.272|
;;;345                        case 10:
;;;346                        case 15:
00009e  bf00              NOP      
;;;347                            SetDoneFlag.SD.SD1 = 1;             //袋重设定值,滤波系数需修改
0000a0  482b              LDR      r0,|L14.336|
0000a2  7800              LDRB     r0,[r0,#0]  ; SetDoneFlag
0000a4  0840              LSRS     r0,r0,#1
0000a6  0040              LSLS     r0,r0,#1
0000a8  1c40              ADDS     r0,r0,#1
0000aa  4929              LDR      r1,|L14.336|
0000ac  7008              STRB     r0,[r1,#0]
;;;348                            break;
0000ae  e02f              B        |L14.272|
;;;349                        case 11:
;;;350                        case 19:
0000b0  bf00              NOP      
;;;351                            SetDoneFlag.SD.SD2 = 1;             //粗细流切换值,粗细流开关需修改
0000b2  4827              LDR      r0,|L14.336|
0000b4  7800              LDRB     r0,[r0,#0]  ; SetDoneFlag
0000b6  2102              MOVS     r1,#2
0000b8  4388              BICS     r0,r0,r1
0000ba  1c80              ADDS     r0,r0,#2
0000bc  4924              LDR      r1,|L14.336|
0000be  7008              STRB     r0,[r1,#0]
;;;352                            break;
0000c0  e026              B        |L14.272|
;;;353                        case 12:
;;;354                        case 13:
0000c2  bf00              NOP      
;;;355                            SetDoneFlag.SD.SD4 = 1;             //手动落差,袋重净差需修改.
0000c4  4822              LDR      r0,|L14.336|
0000c6  7800              LDRB     r0,[r0,#0]  ; SetDoneFlag
0000c8  2108              MOVS     r1,#8
0000ca  4388              BICS     r0,r0,r1
0000cc  3008              ADDS     r0,r0,#8
0000ce  4920              LDR      r1,|L14.336|
0000d0  7008              STRB     r0,[r1,#0]
;;;356                            break;
0000d2  e01d              B        |L14.272|
;;;357                        case 14:
;;;358                        case 17:
0000d4  bf00              NOP      
;;;359                        case 21:
0000d6  bf00              NOP      
;;;360                            SetDoneFlag.SD.SD7 = 1;             //袋重修正值,闭环校正开关,抵达时间
0000d8  481d              LDR      r0,|L14.336|
0000da  7800              LDRB     r0,[r0,#0]  ; SetDoneFlag
0000dc  2140              MOVS     r1,#0x40
0000de  4388              BICS     r0,r0,r1
0000e0  3040              ADDS     r0,r0,#0x40
0000e2  491b              LDR      r1,|L14.336|
0000e4  7008              STRB     r0,[r1,#0]
;;;361                            break;
0000e6  e013              B        |L14.272|
;;;362                        case 16:
;;;363                        case 20:
0000e8  bf00              NOP      
;;;364                            SetDoneFlag.SD.SD5 = 1;             //开环追踪,追踪袋数
0000ea  4819              LDR      r0,|L14.336|
0000ec  7800              LDRB     r0,[r0,#0]  ; SetDoneFlag
0000ee  2110              MOVS     r1,#0x10
0000f0  4388              BICS     r0,r0,r1
0000f2  3010              ADDS     r0,r0,#0x10
0000f4  4916              LDR      r1,|L14.336|
0000f6  7008              STRB     r0,[r1,#0]
;;;365                            break;
0000f8  e00a              B        |L14.272|
                  |L14.250|
0000fa  e020              B        |L14.318|
;;;366                        case 22:
;;;367                        case 23:
0000fc  bf00              NOP      
;;;368                        case 24:
0000fe  bf00              NOP      
;;;369                            SetDoneFlag1.SD.SD1 = 1;            //时间参数已更新
000100  4814              LDR      r0,|L14.340|
000102  7800              LDRB     r0,[r0,#0]  ; SetDoneFlag1
000104  0840              LSRS     r0,r0,#1
000106  0040              LSLS     r0,r0,#1
000108  1c40              ADDS     r0,r0,#1
00010a  4912              LDR      r1,|L14.340|
00010c  7008              STRB     r0,[r1,#0]
;;;370                            break;
00010e  bf00              NOP      
                  |L14.272|
000110  bf00              NOP                            ;339
;;;371    				}
;;;372    				usRegHoldingBuf[iRegIndex] = *pucRegBuffer++ << 8;
000112  7821              LDRB     r1,[r4,#0]
000114  1c64              ADDS     r4,r4,#1
000116  0208              LSLS     r0,r1,#8
000118  0079              LSLS     r1,r7,#1
00011a  4b0c              LDR      r3,|L14.332|
00011c  5258              STRH     r0,[r3,r1]
;;;373    				usRegHoldingBuf[iRegIndex] |= *pucRegBuffer++;
00011e  7820              LDRB     r0,[r4,#0]
000120  1c64              ADDS     r4,r4,#1
000122  0079              LSLS     r1,r7,#1
000124  5a59              LDRH     r1,[r3,r1]
000126  4308              ORRS     r0,r0,r1
000128  0079              LSLS     r1,r7,#1
00012a  5258              STRH     r0,[r3,r1]
;;;374    				iRegIndex++;
00012c  1c7f              ADDS     r7,r7,#1
;;;375    				usNRegs--;
00012e  1e50              SUBS     r0,r2,#1
000130  b282              UXTH     r2,r0
                  |L14.306|
000132  2a00              CMP      r2,#0                 ;330
000134  dc8b              BGT      |L14.78|
;;;376    			}
;;;377    			MBHoldingRegWrite();
000136  f7fffffe          BL       MBHoldingRegWrite
00013a  bf00              NOP                            ;315
                  |L14.316|
00013c  e001              B        |L14.322|
                  |L14.318|
;;;378    		}
;;;379    	}
;;;380    	else{
;;;381    		eStatus = MB_ENOREG;
00013e  2001              MOVS     r0,#1
000140  9000              STR      r0,[sp,#0]
                  |L14.322|
;;;382    	}
;;;383    	return eStatus;
000142  9800              LDR      r0,[sp,#0]
;;;384    }
000144  bdf8              POP      {r3-r7,pc}
;;;385    
                          ENDP

000146  0000              DCW      0x0000
                  |L14.328|
                          DCD      usRegHoldingStart
                  |L14.332|
                          DCD      usRegHoldingBuf
                  |L14.336|
                          DCD      SetDoneFlag
                  |L14.340|
                          DCD      SetDoneFlag1

                          AREA ||i.eMBRegInputCB||, CODE, READONLY, ALIGN=2

                  eMBRegInputCB PROC
;;;281    eMBErrorCode
;;;282    eMBRegInputCB( UCHAR * pucRegBuffer, USHORT usAddress, USHORT usNRegs )
000000  b570              PUSH     {r4-r6,lr}
;;;283    {
000002  4603              MOV      r3,r0
000004  460c              MOV      r4,r1
;;;284        eMBErrorCode    eStatus = MB_ENOERR;
000006  2600              MOVS     r6,#0
;;;285        int             iRegIndex;
;;;286    
;;;287        if((usAddress >= REG_INPUT_START)
000008  2c01              CMP      r4,#1
00000a  db18              BLT      |L15.62|
;;;288            && (usAddress + usNRegs <= REG_INPUT_START + REG_INPUT_NREGS)){
00000c  18a0              ADDS     r0,r4,r2
00000e  280d              CMP      r0,#0xd
000010  dc15              BGT      |L15.62|
;;;289            MBInputRegRead();
000012  f7fffffe          BL       MBInputRegRead
;;;290            iRegIndex = ( int )( usAddress - usRegInputStart );
000016  480b              LDR      r0,|L15.68|
000018  8800              LDRH     r0,[r0,#0]  ; usRegInputStart
00001a  1a25              SUBS     r5,r4,r0
;;;291            while( usNRegs > 0 ){
00001c  e00c              B        |L15.56|
                  |L15.30|
;;;292                *pucRegBuffer++ = ( unsigned char )( usRegInputBuf[iRegIndex] >> 8 );
00001e  0068              LSLS     r0,r5,#1
000020  4909              LDR      r1,|L15.72|
000022  5a08              LDRH     r0,[r1,r0]
000024  1200              ASRS     r0,r0,#8
000026  7018              STRB     r0,[r3,#0]
000028  1c5b              ADDS     r3,r3,#1
;;;293                *pucRegBuffer++ = ( unsigned char )( usRegInputBuf[iRegIndex] & 0xFF );
00002a  0068              LSLS     r0,r5,#1
00002c  5c08              LDRB     r0,[r1,r0]
00002e  7018              STRB     r0,[r3,#0]
000030  1c5b              ADDS     r3,r3,#1
;;;294                iRegIndex++;
000032  1c6d              ADDS     r5,r5,#1
;;;295                usNRegs--;
000034  1e50              SUBS     r0,r2,#1
000036  b282              UXTH     r2,r0
                  |L15.56|
000038  2a00              CMP      r2,#0                 ;291
00003a  dcf0              BGT      |L15.30|
00003c  e000              B        |L15.64|
                  |L15.62|
;;;296            }
;;;297        }
;;;298        else{
;;;299            eStatus = MB_ENOREG;
00003e  2601              MOVS     r6,#1
                  |L15.64|
;;;300        }
;;;301        return eStatus;
000040  4630              MOV      r0,r6
;;;302    }
000042  bd70              POP      {r4-r6,pc}
;;;303    
                          ENDP

                  |L15.68|
                          DCD      usRegInputStart
                  |L15.72|
                          DCD      usRegInputBuf

                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  RxBuf
                          %        80
                  TxBuf
                          %        60
                  usRegInputBuf
                          %        24
                  usRegHoldingBuf
                          %        56

                          AREA ||.data||, DATA, ALIGN=1

                  RxCnt
000000  00                DCB      0x00
                  TxCnt
000001  00                DCB      0x00
                  data_in_len
000002  00                DCB      0x00
                  ||dil||
000003  00                DCB      0x00
                  data_out_len
000004  00                DCB      0x00
                  ||dol||
000005  00                DCB      0x00
                  usRegInputStart
000006  0001              DCW      0x0001
                  usRegHoldingStart
000008  0001              DCW      0x0001
                  usRegCoilsStart
00000a  0001              DCW      0x0001
                  usRegCoilsBuf
                          DCDU     0x00000000
                  usRegDiscreteStart
000010  0001              DCW      0x0001
                  usRegDiscreteBuf
000012  0000              DCB      0x00,0x00
                          DCDU     0x00000000
000018  0000              DCB      0x00,0x00
                  SetDoneFlag
00001a  00                DCB      0x00
                  SetDoneFlag1
00001b  00                DCB      0x00

                          AREA ||i.__ARM_common_switch8||, COMGROUP=__ARM_common_switch8, CODE, READONLY, ALIGN=1

                  __ARM_common_switch8 PROC
000000  b430              PUSH     {r4,r5}
000002  4674              MOV      r4,lr
000004  1e64              SUBS     r4,r4,#1
000006  7825              LDRB     r5,[r4,#0]
000008  1c64              ADDS     r4,r4,#1
00000a  42ab              CMP      r3,r5
00000c  d304              BCC      |L101.24|
                  |L101.14|
00000e  5d63              LDRB     r3,[r4,r5]
000010  005b              LSLS     r3,r3,#1
000012  18e3              ADDS     r3,r4,r3
000014  bc30              POP      {r4,r5}
000016  4718              BX       r3
                  |L101.24|
000018  461d              MOV      r5,r3
00001a  e7f8              B        |L101.14|
                          ENDP

